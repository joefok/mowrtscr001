<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0"
  />
  <title>Gesture Tetris â€” Open Hand + Directional Movement</title>

  <!-- Prevent favicon 404 -->
  data:,
  https://cdn.jsdelivr.net
  https://unpkg.com

  <style>
    :root { --tile: 30px; }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      overflow: hidden;
      background: #111;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: #fff;
    }
    canvas {
      width: 100vw;
      height: 80vh;
      background: #000;
      display: block;
    }
    video {
      position: fixed;
      bottom: 96px; /* leave room for controls */
      right: 10px;
      width: 128px;
      height: 96px;
      border: 2px solid #0ff;
      z-index: 10;
      transform: scaleX(-1); /* mirror for natural control */
    }
    #diag {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,.6);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
      z-index: 10;
      max-width: 92vw;
      white-space: pre-wrap;
    }
    #hud {
      position: fixed;
      left: 10px;
      bottom: 10px;
      z-index: 10;
      background: rgba(0,0,0,.5);
      border: 1px solid rgba(255,255,255,.2);
      border-radius: 8px;
      padding: 8px 10px;
      font-size: 12px;
      max-width: 70vw;
    }
    #hud h4 { margin: 0 0 6px 0; font-size: 13px; }
    #hud .row {
      display: flex;
      gap: 12px;
      margin: 6px 0;
      flex-wrap: wrap;
      align-items: center;
    }
    #hud code { color: #9cf; }

    /* Controls */
    #controls { display: flex; gap: 10px; align-items: center; }
    #controls .label { opacity: .85; font-size: 12px; }
    #controls input[type="range"] { width: 140px; }
    #camToggle, #calibBtn {
      z-index: 11;
      background: #0b3d46;
      border: 1px solid #0ff;
      color: #0ff;
      border-radius: 6px;
      font-size: 12px;
      padding: 6px 10px;
      cursor: pointer;
      user-select: none;
    }
    #camToggle:hover, #calibBtn:hover { background: #0e4f5a; }
    #camToggle { position: fixed; right: 10px; bottom: 10px; }

    /* Gesture SVG Icons Row */
    #gestureIcons { display: flex; gap: 10px; align-items: center; }
    #gestureIcons .icon {
      width: 28px; height: 28px;
      opacity: 0.3;
      transition: transform .12s ease, opacity .12s ease, filter .12s ease;
    }
    #gestureIcons .icon.active {
      opacity: 1;
      transform: scale(1.12);
      filter: drop-shadow(0 0 6px rgba(0,255,255,0.75));
    }
    .icon.move { stroke: #0ff; }
    .icon.rotate { stroke: #a0f; }
    .icon.drop { stroke: #f9a825; } /* amber */
    .icon path, .icon line, .icon polyline, .icon circle {
      stroke-width: 2.2; fill: none; stroke-linecap: round; stroke-linejoin: round;
    }
  </style>
</head>
<body>
  <!-- UI -->
  <div id="diag">Booting...</div>
  <canvas id="tetris"></canvas>
  <video id="camera" autoplay playsinline muted></video>

  <div id="hud">
    <h4>Gesture Tetris</h4>
    <div class="row">
      <div><b>Mode:</b> <span id="modeLabel">hand</span></div>
      <div><b>Score:</b> <span id="score">0</span></div>
      <div><b>Lines:</b> <span id="lines">0</span></div>
      <div><b>Pieces:</b> <span id="pieces">0</span></div>
    </div>

    <!-- Gesture icons (no help text, just visuals) -->
    <div class="row" id="gestureIcons">
      <!-- Move Left -->
      <svg id="iconLeft" class="icon move" viewBox="0 0 24 24" aria-hidden="true">
        <polyline points="14,6 8,12 14,18"></polyline>
        <line x1="8" y1="12" x2="20" y2="12"></line>
      </svg>
      <!-- Move Right -->
      <svg id="iconRight" class="icon move" viewBox="0 0 24 24" aria-hidden="true">
        <polyline points="10,6 16,12 10,18"></polyline>
        <line x1="4" y1="12" x2="16" y2="12"></line>
      </svg>
      <!-- Rotate -->
      <svg id="iconRotate" class="icon rotate" viewBox="0 0 24 24" aria-hidden="true">
        <polyline points="16,3 16,8 21,8"></polyline>
        <path d="M20,8a8,8 0 1 1 -2.4 -5.7"></path>
      </svg>
      <!-- Soft Drop -->
      <svg id="iconDrop" class="icon drop" viewBox="0 0 24 24" aria-hidden="true">
        <polyline points="6,10 12,16 18,10"></polyline>
        <line x1="12" y1="4" x2="12" y2="16"></line>
      </svg>
    </div>

    <!-- Controls -->
    <div class="row" id="controls">
      <div class="label"><b>Sensitivity</b></div>
      <input id="sens" type="range" min="0.2" max="1.0" step="0.05" value="0.35" />
      <span id="sensVal">0.35</span>
      <button id="calibBtn" type="button">ðŸŽ¯ Calibrate</button>
      <div class="label"><b>Keys:</b> <code>C</code> camera â€¢ <code>N</code> calibrate</div>
    </div>
  </div>

  <button id="camToggle" type="button">ðŸ“· Hide</button>

  <script>
    // ==================== CONFIG ====================
    const MODE = 'hand'; // hand only (open-hand requirement)

    // Movement feel (DAS/ARR) for left/right
    const DAS_MS = 220;  // initial delay before auto-repeat
    const ARR_MS = 70;   // auto-repeat rate while held

    // Smoothing windows
    const SMOOTH_FRAMES = 5; // moving average for dx baseline
    const MOTION_FRAMES = 3; // moving average for motion dx/dy

    // Gravity
    const fallMsBase = 900;  // default gravity
    const fallMsSoft = 250;  // while soft-dropping

    // Rotation event timing
    const ROTATE_COOLDOWN_MS = 260; // minimum time between rotations
    const SUPPRESS_AFTER_ROTATE_MS = 250; // suppress other gestures briefly after rotate
    const ACTION_SWITCH_MIN_MS = 100;     // minimal dwell before switching actions

    // High-certainty gating
    const FRAMES_CONFIRM = 4; // frames to confirm an action

    // Open-hand checks
    const CURL_EXTENDED_COS = 0.80;  // finger is "straight" if average cosine > this
    const SPLAY_K_ADJACENT = 0.22;   // min adjacent fingertip spacing (% of hand size)
    const SPLAY_K_THUMB    = 0.25;   // min thumb-index spacing (% of hand size)

    window.addEventListener('DOMContentLoaded', () => {
      const m = document.getElementById('modeLabel');
      if (m) m.textContent = MODE;
    });
  </script>

  <!-- ====== Loader with CDN fallback (CPU-safe) ====== -->
  <script>
    (function loadLibs(){
      const head = document.head;
      const diagEl = document.getElementById('diag');
      const log = (msg) => { if (diagEl) diagEl.innerHTML = msg; else console.log(msg.replace(/<[^>]+>/g,'')); };
      const add = (src) => new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = src; s.async = true; s.crossOrigin = 'anonymous'; s.referrerPolicy = 'no-referrer';
        s.onload = () => resolve(src);
        s.onerror = () => reject(new Error('Failed: ' + src));
        head.appendChild(s);
      });
      const webglSupported = () => {
        try {
          const c = document.createElement('canvas');
          return !!(c.getContext('webgl2') || c.getContext('webgl') || c.getContext('experimental-webgl'));
        } catch { return false; }
      };

      async function boot() {
        try {
          // ---- TFJS ----
          log('Loading TensorFlow.js...');
          try { await add("https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"); }
          catch { await add("https://unpkg.com/@tensorflow/tfjs@4.18.0/dist/tf.min.js"); }

          // Choose backend without WebGL spam
          if (webglSupported()) { try { await tf.setBackend('webgl'); } catch { await tf.setBackend('cpu'); } }
          else { await tf.setBackend('cpu'); }
          await tf.ready();

          // ---- Hand Pose Detection (MediaPipe Hands runtime) ----
          log('Loading Hand Pose Detection...');
          try { await add("https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection@2.0.1/dist/hand-pose-detection.min.js"); }
          catch { await add("https://unpkg.com/@tensorflow-models/hand-pose-detection@2.0.1/dist/hand-pose-detection.min.js"); }

          log('Loading MediaPipe Hands runtime...');
          try { await add("https://cdn.jsdelivr.net/npm/@mediapipe/hands@latest"); }
          catch { await add("https://unpkg.com/@mediapipe/hands@latest"); }

          const tfOK  = !!window.tf;
          const libOK = !!window.handPoseDetection;
          log(`TFJS: ${tfOK ? '<b>ok</b>' : '<i>missing</i>'} â€¢ Hand-Pose: ${libOK ? '<b>ok</b>' : '<i>missing</i>'}`);

          if (tfOK && libOK) setTimeout(() => { if (typeof startApp === 'function') startApp(); }, 0);
        } catch (e) {
          log('Loader error:<br>' + (e?.message || e));
          console.error(e);
        }
      }
      boot();
    })();
  </script>

  <!-- ====== App: Stacking Tetris + Open-hand Directional Gestures ====== -->
  <script>
    async function startApp() {
      // Helpers
      const $ = (id) => document.getElementById(id);
      const setText = (el, text) => { if (el) el.textContent = text; };
      const vsub = (a, b) => ({ x: (a?.x||0)-(b?.x||0), y: (a?.y||0)-(b?.y||0) });
      const vlen = (u) => Math.hypot(u.x, u.y);
      const vnorm = (u) => { const n = vlen(u)||1; return {x:u.x/n, y:u.y/n}; };
      const vdot = (u, v) => u.x*v.x + u.y*v.y;
      const dist = (a, b) => Math.hypot((a?.x||0)-(b?.x||0), (a?.y||0)-(b?.y||0));
      const scoreOK = (k, t=0.5) => !k || k.score == null || k.score >= t; // if score absent, accept

      const diag = $('diag');
      const canvas = $('tetris');
      const ctx = canvas.getContext('2d');
      const video = $('camera');
      const camToggleBtn = $('camToggle');

      // HUD refs
      const scoreEl = $('score'), linesEl = $('lines'), piecesEl = $('pieces');
      const sensRange = $('sens'), sensVal = $('sensVal'), calibBtn = $('calibBtn');

      // SVG Icons
      const iconLeft = $('iconLeft');
      const iconRight = $('iconRight');
      const iconRotate = $('iconRotate');
      const iconDrop = $('iconDrop');
      const icons = { left: iconLeft, right: iconRight, rotate: iconRotate, drop: iconDrop };
      const setIcon = (name, active) => { const el = icons[name]; if (el) el.classList.toggle('active', !!active); };
      const setOnlyIcon = (name) => { Object.keys(icons).forEach(n => setIcon(n, n === name)); };
      const flashIcon = (name, ms=140) => { setOnlyIcon(name); setTimeout(() => setOnlyIcon(null), ms); };

      // Board setup
      const TILE = 30, COLS = 10, ROWS = 20;
      canvas.width = COLS * TILE; canvas.height = ROWS * TILE;

      const COLORS = {
        0: '#000000', 1: '#00f0f0', 2: '#0000f0', 3: '#f0a000',
        4: '#f0f000', 5: '#00f000', 6: '#a000f0', 7: '#f00000',
      };

      const shapeById = (id) => ({
        1: [[1,1,1,1]],
        2: [[2,0,0],[2,2,2]],
        3: [[0,0,3],[3,3,3]],
        4: [[4,4],[4,4]],
        5: [[0,5,5],[5,5,0]],
        6: [[0,6,0],[6,6,6]],
        7: [[7,7,0],[0,7,7]],
      }[id].map(r => r.slice()));

      // 7-bag RNG
      let bag = [];
      function refillBag() {
        bag = [1,2,3,4,5,6,7];
        for (let i = bag.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [bag[i], bag[j]] = [bag[j], bag[i]];
        }
      }
      const nextId = () => { if (!bag.length) refillBag(); return bag.pop(); };

      // Game state
      const board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
      let active = null;
      let score = 0, lines = 0, pieces = 0;
      const updateHUD = () => { setText(scoreEl, score); setText(linesEl, lines); setText(piecesEl, pieces); };

      // Collisions
      function collides(mat, offX, offY) {
        for (let y = 0; y < mat.length; y++)
          for (let x = 0; x < mat[y].length; x++) {
            const v = mat[y][x]; if (!v) continue;
            const bx = offX + x, by = offY + y;
            if (bx < 0 || bx >= COLS || by >= ROWS) return true;
            if (by >= 0 && board[by][bx]) return true;
          }
        return false;
      }

      // Merge & clear
      function merge() {
        for (let y=0; y<active.matrix.length; y++)
          for (let x=0; x<active.matrix[y].length; x++) {
            const v = active.matrix[y][x];
            if (v && active.y + y >= 0) board[active.y + y][active.x + x] = v;
          }
      }
      function clearLines() {
        let cleared = 0;
        for (let y = ROWS - 1; y >= 0; ) {
          if (board[y].every(v => v !== 0)) {
            board.splice(y, 1);
            board.unshift(Array(COLS).fill(0));
            cleared++;
          } else y--;
        }
        if (cleared) {
          const table = {1:100, 2:300, 3:500, 4:800};
          score += table[cleared] || (cleared * 200);
          lines += cleared; updateHUD();
        }
      }

      // Spawn with auto-restart on Game Over
      let restarting = false;
      function gameOverRestart(delayMs = 1200) {
        if (restarting) return;
        restarting = true;

        // Stop soft drop & movement and reset gesture states
        softDropActive = false; heldDir = 0; nextMoveAt = 0; dxHistory.length = 0;
        leftCnt = rightCnt = upCnt = downCnt = 0;
        currentAction = null; suppressUntil = 0;
        dxQ.length = dyQ.length = 0; prevCenter = null;

        // Clear board & stats
        for (let r = 0; r < ROWS; r++) board[r].fill(0);
        score = 0; lines = 0; pieces = 0; updateHUD();

        // Clear active and redraw empty board
        active = null; draw();

        // Reset bag & gravity baseline
        bag.length = 0; refillBag();
        lastFallAt = performance.now();

        // Spawn again after delay
        setTimeout(() => {
          spawn(); draw();
          restarting = false;
          setText(diag, 'Ready.');
        }, delayMs);
      }

      function spawn() {
        const id = nextId();
        const mat = shapeById(id);
        const x = Math.floor(COLS / 2 - mat[0].length / 2);
        const y = -2;
        active = { id, matrix: mat, x, y };
        pieces++; updateHUD();
        if (collides(active.matrix, active.x, active.y)) {
          // Game over (blocked spawn) â†’ auto restart
          gameOverRestart();
          return;
        }
      }

      // Rotation + simple wall-kicks
      const rotateCW = (m) => {
        const h = m.length, w = m[0].length;
        const out = Array.from({length: w}, _ => Array(h).fill(0));
        for (let y=0;y<h;y++) for (let x=0;x<w;x++) out[x][h-1-y] = m[y][x];
        return out;
      };
      function tryRotate() {
        const rotated = rotateCW(active.matrix);
        const kicks = [0, -1, 1, -2, 2];
        for (const k of kicks) {
          if (!collides(rotated, active.x + k, active.y)) {
            active.matrix = rotated; active.x += k; draw(); return true;
          }
        }
        return false;
      }

      // Movement + lock (with top-out detection)
      function tryMove(dir) {
        if (!collides(active.matrix, active.x + dir, active.y)) {
          active.x += dir; draw();
        }
      }
      function lock() {
        const topOut = active.y < 0;  // if piece locks above visible area -> Game Over
        merge();
        if (topOut) { draw(); gameOverRestart(); return; }
        clearLines();
        spawn();
        draw();
      }

      // Draw
      function draw() {
        ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        // Board
        for (let y=0;y<ROWS;y++) for (let x=0;x<COLS;x++) {
          const v = board[y][x]; if (!v) continue;
          ctx.fillStyle = COLORS[v];
          ctx.fillRect(x*30, y*30, 30, 30);
          ctx.strokeStyle = 'rgba(0,0,0,0.35)';
          ctx.strokeRect(x*30+0.5, y*30+0.5, 29, 29);
        }
        // Active
        if (active) for (let y=0;y<active.matrix.length;y++) for (let x=0;x<active.matrix[y].length;x++) {
          const v = active.matrix[y][x]; if (!v) continue;
          const by = active.y + y, bx = active.x + x; if (by < 0) continue;
          ctx.fillStyle = COLORS[v];
          ctx.fillRect(bx*30, by*30, 30, 30);
          ctx.strokeStyle = 'rgba(0,0,0,0.35)';
          ctx.strokeRect(bx*30+0.5, by*30+0.5, 29, 29);
        }
        // Grid
        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        for (let gx=1; gx<COLS; gx++) { ctx.beginPath(); ctx.moveTo(gx*30, 0); ctx.lineTo(gx*30, canvas.height); ctx.stroke(); }
        for (let gy=1; gy<ROWS; gy++) { ctx.beginPath(); ctx.moveTo(0, gy*30); ctx.lineTo(canvas.width, gy*30); ctx.stroke(); }
      }

      // Gravity (time-based)
      let lastFallAt = performance.now();
      let softDropActive = false;
      function setSoftDrop(active) { softDropActive = !!active; setIcon('drop', softDropActive); }
      function step(now) {
        const interval = softDropActive ? fallMsSoft : fallMsBase;
        if (now - lastFallAt >= interval) {
          lastFallAt = now;
          if (!active) { requestAnimationFrame(step); return; }
          if (!collides(active.matrix, active.x, active.y + 1)) active.y++;
          else lock();
          draw();
        }
        requestAnimationFrame(step);
      }

      // ====== Exclusive, Open-hand Directional Gesture Engine ======
      let dxHistory = [];
      let neutralDx = 0;          // not essential here; kept for completeness
      let heldDir = 0;            // -1, 0, +1 for DAS/ARR
      let nextMoveAt = 0;         // timestamp for next auto-repeat
      let lastRotate = 0;

      // Multi-frame confirmation counters
      let leftCnt = 0, rightCnt = 0, upCnt = 0, downCnt = 0;

      // Exclusivity state
      let currentAction = null;   // 'rotate' | 'drop' | 'moveLeft' | 'moveRight' | null
      let actionSince = 0;
      let suppressUntil = 0;

      // Motion smoothing queues
      const dxQ = [], dyQ = [];
      let prevCenter = null;

      // Sensitivity UI (affects movement thresholds)
      let sensitivity = parseFloat(sensRange?.value || '0.35');
      const updateSensitivityLabel = () => { if (sensVal) sensVal.textContent = sensitivity.toFixed(2); };
      updateSensitivityLabel();
      sensRange?.addEventListener('input', () => { sensitivity = parseFloat(sensRange.value); updateSensitivityLabel(); });

      function calibrateNeutral(currentDxAvg = 0) {
        neutralDx = currentDxAvg;
        const old = diag.textContent;
        diag.textContent = 'Neutral calibrated.';
        setTimeout(() => { diag.textContent = old; }, 800);
      }
      calibBtn?.addEventListener('click', () => calibrateNeutral(dxHistory.length ? dxHistory.reduce((a,b)=>a+b,0)/dxHistory.length : 0));
      window.addEventListener('keydown', (e) => {
        const k = e.key.toLowerCase();
        if (k === 'n') calibrateNeutral(dxHistory.length ? dxHistory.reduce((a,b)=>a+b,0)/dxHistory.length : 0);
      });

      // Camera
      setText(diag, 'Requesting camera...');
      if (!navigator.mediaDevices?.getUserMedia) {
        setText(diag, 'getUserMedia not supported. Use HTTPS / modern browser.');
        return;
      }
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'user', width: { ideal: 960 }, height: { ideal: 720 } },
        audio: false
      });
      video.srcObject = stream;
      await new Promise(r => { if (video.readyState >= 2) r(); else video.onloadeddata = r; });
      try { await video.play(); } catch {}

      // Detector (MediaPipe Hands)
      setText(diag, 'Creating MediaPipe Hands detector...');
      const model = handPoseDetection.SupportedModels.MediaPipeHands;
      const detector = await handPoseDetection.createDetector(model, {
        runtime: 'mediapipe',
        modelType: 'lite',
        solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands@latest',
      });

      // Start game
      refillBag();
      spawn(); draw();
      requestAnimationFrame(step);
      setText(diag, 'Ready.');

      // Camera toggle (+ auto-hide after 5s)
      function setCamVisible(show) {
        video.style.display = show ? 'block' : 'none';
        camToggleBtn.textContent = show ? 'ðŸ“· Hide' : 'ðŸ“· Show';
      }
      let camVisible = true; setCamVisible(camVisible);
      setTimeout(() => { if (camVisible) { camVisible = false; setCamVisible(camVisible); } }, 5000);
      camToggleBtn.addEventListener('click', () => { camVisible = !camVisible; setCamVisible(camVisible); });
      window.addEventListener('keydown', (e) => { if (e.key.toLowerCase() === 'c') { camVisible = !camVisible; setCamVisible(camVisible); } });

      // Counter update with decay
      const upd = (cnt, cond) => {
        if (cond) return Math.min(8, cnt + 1);
        return Math.max(0, cnt - 1);
      };

      // Finger curl (index/middle/ring/pinky)
      function fingerCurl(byName, prefix) {
        const mcp = byName[`${prefix}_mcp`];
        const pip = byName[`${prefix}_pip`];
        const dip = byName[`${prefix}_dip`];
        const tip = byName[`${prefix}_tip`];
        if (!mcp || !pip || !dip || !tip) return 0;
        const u1 = vnorm(vsub(pip, mcp));
        const u2 = vnorm(vsub(dip, pip));
        const u3 = vnorm(vsub(tip, dip));
        const c12 = vdot(u1, u2);
        const c23 = vdot(u2, u3);
        return (c12 + c23) / 2; // closer to 1 = straight
      }
      function thumbCurl(byName) {
        const mcp = byName['thumb_mcp'];
        const ip  = byName['thumb_ip'];
        const tip = byName['thumb_tip'];
        if (!mcp || !ip || !tip) return 0;
        const u1 = vnorm(vsub(ip, mcp));
        const u2 = vnorm(vsub(tip, ip));
        return vdot(u1, u2);
      }

      // ====== Detection loop (open-hand + directional motion) ======
      async function detect() {
        try {
          let now = performance.now();

          // Defaults (no action)
          let newAction = currentAction;
          const inSuppress = now < suppressUntil;

          const hands = await detector.estimateHands(video, { flipHorizontal: true });
          if (hands.length) {
            const kps = hands[0].keypoints || [];
            const byName = Object.fromEntries(kps.map(k => [k.name, k]));

            // Confidence gate basic joints
            const wrist  = byName['wrist'];
            const idxMcp = byName['index_finger_mcp'];
            const midMcp = byName['middle_finger_mcp'];
            const rngMcp = byName['ring_finger_mcp'];
            const pnkMcp = byName['pinky_finger_mcp'];
            const idxTip = byName['index_finger_tip'];
            const midTip = byName['middle_finger_tip'];
            const rngTip = byName['ring_finger_tip'];
            const pnkTip = byName['pinky_finger_tip'];
            const thTip  = byName['thumb_tip'];

            if (scoreOK(wrist) && scoreOK(idxMcp) && scoreOK(pnkMcp)) {
              // Hand size & center
              const palmWidth = dist(idxMcp, pnkMcp);
              const handLen   = midMcp ? dist(wrist, midMcp) : palmWidth;
              const handSize  = Math.max(60, (palmWidth + handLen) * 0.5);

              // --- OPEN HAND CHECK (all five extended + splay) ---
              const cIndex  = fingerCurl(byName, 'index_finger');
              const cMiddle = fingerCurl(byName, 'middle_finger');
              const cRing   = fingerCurl(byName, 'ring_finger');
              const cPinky  = fingerCurl(byName, 'pinky_finger');
              const cThumb  = thumbCurl(byName);
              const allExtended = (
                cIndex  > CURL_EXTENDED_COS &&
                cMiddle > CURL_EXTENDED_COS &&
                cRing   > CURL_EXTENDED_COS &&
                cPinky  > CURL_EXTENDED_COS &&
                cThumb  > CURL_EXTENDED_COS
              );

              const splayOK =
                idxTip && midTip && rngTip && pnkTip && thTip &&
                dist(idxTip, midTip) > handSize * SPLAY_K_ADJACENT &&
                dist(midTip, rngTip) > handSize * SPLAY_K_ADJACENT &&
                dist(rngTip, pnkTip) > handSize * (SPLAY_K_ADJACENT - 0.02) &&
                dist(thTip, idxTip)  > handSize * SPLAY_K_THUMB;

              const openHandOK = allExtended && splayOK;

              // Hand center (palm center approx.)
              const center = {
                x: (wrist.x + idxMcp.x + midMcp.x + rngMcp.x + pnkMcp.x) / 5,
                y: (wrist.y + idxMcp.y + midMcp.y + rngMcp.y + pnkMcp.y) / 5,
              };

              // Motion (only when open-hand gate is satisfied)
              if (openHandOK) {
                if (prevCenter) {
                  const dx = center.x - prevCenter.x;
                  const dy = center.y - prevCenter.y;
                  dxQ.push(dx); if (dxQ.length > MOTION_FRAMES) dxQ.shift();
                  dyQ.push(dy); if (dyQ.length > MOTION_FRAMES) dyQ.shift();
                  const avgDx = dxQ.reduce((a,b)=>a+b,0) / dxQ.length;
                  const avgDy = dyQ.reduce((a,b)=>a+b,0) / dyQ.length;

                  // Adaptive movement thresholds (smaller value = more sensitive)
                  const moveThresh = handSize * sensitivity;

                  const leftCond  = avgDx < -moveThresh;
                  const rightCond = avgDx >  moveThresh;
                  const upCond    = avgDy < -moveThresh; // up is negative Y
                  const downCond  = avgDy >  moveThresh;

                  // Update counters with decay
                  leftCnt  = upd(leftCnt,  leftCond);
                  rightCnt = upd(rightCnt, rightCond);
                  upCnt    = upd(upCnt,    upCond);
                  downCnt  = upd(downCnt,  downCond);

                  // --- Exclusive decision ---
                  if (!inSuppress) {
                    // Rotate is an event from UP movement
                    if (upCnt >= FRAMES_CONFIRM && (now - lastRotate > ROTATE_COOLDOWN_MS)) {
                      if (tryRotate()) {
                        flashIcon('rotate', 180);
                      }
                      lastRotate = now;
                      suppressUntil = now + SUPPRESS_AFTER_ROTATE_MS;
                      // Reset continuous actions and counters around rotate
                      setSoftDrop(false);
                      heldDir = 0; nextMoveAt = 0;
                      leftCnt = rightCnt = upCnt = downCnt = 0;
                      newAction = null;
                      actionSince = now;
                    } else {
                      // Otherwise, pick one continuous action by priority: drop > right > left
                      const candidates = [
                        {name:'drop', score: downCnt, prio: 3},
                        {name:'moveRight', score: rightCnt, prio: 2},
                        {name:'moveLeft',  score: leftCnt,  prio: 1},
                      ].sort((a,b)=> b.score - a.score || b.prio - a.prio);

                      const top = candidates[0];
                      if (top.score >= FRAMES_CONFIRM) {
                        // Minimal dwell to avoid fast switching
                        if (currentAction && top.name !== currentAction && (now - actionSince) < ACTION_SWITCH_MIN_MS) {
                          newAction = currentAction;
                        } else {
                          newAction = top.name;
                        }
                      } else {
                        newAction = null;
                      }
                    }
                  }
                }
                prevCenter = center;
              } else {
                // Open hand not detected: reset action/counters gently
                prevCenter = center;
                leftCnt = Math.max(0, leftCnt-2);
                rightCnt = Math.max(0, rightCnt-2);
                upCnt = Math.max(0, upCnt-2);
                downCnt = Math.max(0, downCnt-2);
                // Stop continuous actions if hand not open
                newAction = null;
              }
            }
          } else {
            // No hand: decay and stop
            leftCnt = Math.max(0, leftCnt-2);
            rightCnt = Math.max(0, rightCnt-2);
            upCnt = Math.max(0, upCnt-2);
            downCnt = Math.max(0, downCnt-2);
            newAction = null;
          }

          // Apply exclusivity changes
          if (newAction !== currentAction) {
            currentAction = newAction;
            actionSince = now;
          }

          // Render icons exclusively and apply behavior
          if (currentAction === 'drop') {
            setOnlyIcon('drop');
            setSoftDrop(true);
            // Stop movement while dropping
            heldDir = 0; nextMoveAt = 0;
          } else if (currentAction === 'moveLeft' || currentAction === 'moveRight') {
            setOnlyIcon(currentAction === 'moveLeft' ? 'left' : 'right');
            setSoftDrop(false);

            const dir = currentAction === 'moveLeft' ? -1 : +1;
            if (heldDir !== dir) {
              tryMove(dir);
              heldDir = dir;
              nextMoveAt = now + DAS_MS;
            } else if (now >= nextMoveAt) {
              tryMove(heldDir);
              nextMoveAt = now + ARR_MS;
            }
          } else {
            // No action
            setOnlyIcon(null);
            setSoftDrop(false);
            heldDir = 0; nextMoveAt = 0;
          }

        } catch (e) {
          setText(diag, 'Detection error: ' + (e?.message || e));
          console.error(e);
        }
        requestAnimationFrame(detect);
      }
      detect();
    }
  </script>
</body>
</html>
