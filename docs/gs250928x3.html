<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Victory ‚úåÔ∏è Rotate ‚Ä¢ Drop‚Äëin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      /* Tweak these if you like */
      --min-scale: 0.25;
      --max-scale: 6;
      --rotate-smooth: 0.28; /* 0=no smoothing, 1=instant; 0.2‚Äì0.35 is nice */
      --scale-smooth: 0.25;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: #0b0f16;
      color: #e8f0ff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      overflow: hidden;
    }

    /* Stage: captures gestures */
    #stage {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      /* critical: allow Pointer Events gestures and prevent browser panning/zooming */
      touch-action: none;              /* modern browsers (incl. iOS 13+) */
      -ms-touch-action: none;          /* old Edge/IE */
      user-select: none;
    }

    /* The thing we rotate/zoom/pan */
    #rotatable {
      width: min(75vmin, 780px);
      aspect-ratio: 1 / 1;
      border-radius: 24px;
      box-shadow: 0 20px 50px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.06);
      /* Placeholder visual: replace this block with your own content */
      background:
        radial-gradient(120% 120% at 100% 0%, #2ee6a8 0 30%, transparent 31%),
        radial-gradient(120% 120% at 0% 100%, #6ca8ff 0 35%, transparent 36%),
        linear-gradient(135deg, #182335, #0f1624 60%, #0b0f16);
      display: grid;
      place-items: center;
      color: #dff3ff;
      letter-spacing: 0.02em;
      font-weight: 600;
      text-align: center;

      /* We transform this element via JS */
      transform: translate3d(0px, 0px, 0px) rotate(0deg) scale(1);
      transform-origin: center center;
      will-change: transform;
      /* Improve hit-testing during pan */
      cursor: grab;
    }
    #rotatable:active { cursor: grabbing; }

    /* Subtle helper ring so rotation is visible */
    #rotatable::before {
      content: "";
      position: absolute;
      inset: 10px;
      border-radius: inherit;
      border: 2px dashed rgba(255,255,255,.15);
      pointer-events: none;
    }

    /* On-screen help */
    #hud {
      position: fixed;
      left: 12px; bottom: 12px; right: 12px;
      display: grid;
      gap: 8px;
      font-size: 13px;
      opacity: .85;
      pointer-events: none;
    }
    .pill {
      justify-self: start;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      color: #e6eeff;
      padding: 8px 10px;
      border-radius: 10px;
      backdrop-filter: blur(6px);
    }
    #readout {
      justify-self: end;
      font-variant-numeric: tabular-nums;
    }

    /* Reset button (optional) */
    #resetBtn {
      position: fixed;
      top: 12px; right: 12px;
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.15);
      background: rgba(255,255,255,.07);
      color: #fff;
      font-weight: 600;
      cursor: pointer;
    }
    #resetBtn:active { transform: translateY(1px); }
  </style>
</head>
<body>
  <div id="stage" aria-label="Gesture stage">
    <div id="rotatable" aria-label="Rotatable content">
      <!-- Replace this with your own element (image, canvas, model-viewer, etc.) -->
      <div style="text-shadow: 0 2px 10px rgba(0,0,0,.35)">
        <div style="font-size: clamp(22px,3.5vmin,28px); opacity:.9">Use ‚úåÔ∏è to Rotate</div>
        <div style="font-size: clamp(14px,2.3vmin,16px); opacity:.8; margin-top: 6px">
          Pinch to zoom ‚Ä¢ Drag to pan ‚Ä¢ Double‚Äëtap/D to reset
        </div>
      </div>
    </div>
  </div>

  <button id="resetBtn" type="button" title="Reset (D)">Reset</button>

  <div id="hud">
    <div class="pill">Gestures: ‚úåÔ∏è rotate ‚Ä¢ ü§è zoom ‚Ä¢ ‚òùÔ∏è pan</div>
    <div id="readout" class="pill">x: 0, y: 0, Œ∏: 0¬∞, s: 1.00</div>
  </div>

  <script>
    (function () {
      const stage = document.getElementById('stage');
      const target = document.getElementById('rotatable');
      const readout = document.getElementById('readout');
      const resetBtn = document.getElementById('resetBtn');

      // ----- Transform state -----
      const base = { x: 0, y: 0, rot: 0, scale: 1 };
      const cur  = { ...base };     // smoothed live values
      const tmp  = { x: 0, y: 0, rot: 0, scale: 1 }; // instant (unsmoothed) during gesture

      // Active pointers map
      const pts = new Map(); // pointerId -> {x,y}

      // Two-finger gesture snapshot
      const g = {
        startAngle: 0,
        startDist: 0,
        startCentroid: { x: 0, y: 0 },
        startBase: { x: 0, y: 0, rot: 0, scale: 1 },
        twoFinger: false
      };

      // Utility
      const clamp = (v, lo, hi) => Math.min(Math.max(v, lo), hi);
      const lerp  = (a, b, t) => a + (b - a) * t;

      function angleDeg(p1, p2) {
        return Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI;
      }
      function distance(p1, p2) {
        const dx = p2.x - p1.x, dy = p2.y - p1.y;
        return Math.hypot(dx, dy);
      }
      function centroid(p1, p2) {
        return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
      }

      // Apply CSS transform with smoothing
      function applyTransform() {
        const rs = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--rotate-smooth')) || 0.28;
        const ss = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-smooth'))  || 0.25;

        // Smooth towards tmp/target values
        cur.x     = lerp(cur.x,     tmp.x,     0.5);
        cur.y     = lerp(cur.y,     tmp.y,     0.5);
        cur.rot   = lerp(cur.rot,   tmp.rot,   rs);
        cur.scale = lerp(cur.scale, tmp.scale, ss);

        target.style.transform =
          `translate3d(${cur.x}px, ${cur.y}px, 0) rotate(${cur.rot}deg) scale(${cur.scale})`;

        readout.textContent =
          `x: ${cur.x.toFixed(0)}, y: ${cur.y.toFixed(0)}, Œ∏: ${cur.rot.toFixed(1)}¬∞, s: ${cur.scale.toFixed(2)}`;

        requestAnimationFrame(applyTransform);
      }
      requestAnimationFrame(applyTransform);

      // Convert event to stage-local coords
      function localXY(e) {
        const r = stage.getBoundingClientRect();
        return { x: e.clientX - r.left, y: e.clientY - r.top };
      }

      function onPointerDown(e) {
        // ensure the stage keeps receiving move/ups
        target.setPointerCapture?.(e.pointerId);
        pts.set(e.pointerId, localXY(e));
        if (pts.size === 2) {
          // Start two-finger "victory" gesture
          const [p1, p2] = Array.from(pts.values());
          g.twoFinger = true;
          g.startAngle = angleDeg(p1, p2);
          g.startDist  = distance(p1, p2);
          g.startCentroid = centroid(p1, p2);
          g.startBase = { ...base }; // remember pre-gesture state
        }
        e.preventDefault();
      }

      function onPointerMove(e) {
        if (!pts.has(e.pointerId)) return;
        pts.set(e.pointerId, localXY(e));

        if (pts.size === 2) {
          // ‚úåÔ∏è rotate + pinch zoom around center (smoothed)
          const [p1, p2] = Array.from(pts.values());
          const ang = angleDeg(p1, p2);
          const dist = distance(p1, p2);
          const dAng = ang - g.startAngle;

          // Normalize angle to avoid jumps across +/-180¬∞
          const rot = g.startBase.rot + ((dAng + 540) % 360 - 180);

          const minS = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--min-scale')) || 0.25;
          const maxS = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--max-scale')) || 6;
          const scl = clamp(g.startBase.scale * (dist / Math.max(1, g.startDist)), minS, maxS);

          // Keep pan ‚Äî optional: keep centroid under fingers (advanced: compute delta and adjust base.x/y)
          tmp.rot = rot;
          tmp.scale = scl;
          // Pan stays from base for two-finger unless you want to translate with centroid drift.
          tmp.x = base.x;
          tmp.y = base.y;
        }
        else if (pts.size === 1) {
          // ‚òùÔ∏è pan
          const p = pts.get(e.pointerId);
          // store previous point on the pointer itself for delta
          const prev = e._prev || p; // fallback first move
          const dx = e.movementX ?? (p.x - prev.x);
          const dy = e.movementY ?? (p.y - prev.y);

          tmp.x = base.x + dx;
          tmp.y = base.y + dy;

          // remember for next move
          e._prev = { x: p.x, y: p.y };
        }
        e.preventDefault();
      }

      function endPointer(e) {
        pts.delete(e.pointerId);

        if (g.twoFinger && pts.size < 2) {
          // Gesture finished -> commit tmp to base
          g.twoFinger = false;
          base.rot = cur.rot = tmp.rot;
          base.scale = cur.scale = tmp.scale;
          base.x = cur.x = tmp.x;
          base.y = cur.y = tmp.y;
        }
        else if (!g.twoFinger && pts.size === 0) {
          // End of pan
          base.x = cur.x = tmp.x;
          base.y = cur.y = tmp.y;
        }
        e.preventDefault();
      }

      // Wheel: zoom (and Alt/Option + wheel to rotate)
      function onWheel(e) {
        e.preventDefault();
        const factor = Math.exp(-e.deltaY / 300); // smooth zoom
        if (e.altKey) {
          // rotate with wheel when Alt pressed
          tmp.rot = base.rot = (base.rot + (e.deltaY > 0 ?  -3 : 3));
        } else {
          const minS = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--min-scale')) || 0.25;
          const maxS = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--max-scale')) || 6;
          base.scale = clamp(base.scale * factor, minS, maxS);
          tmp.scale = base.scale;
        }
      }

      // Double‚Äëtap / D to reset
      let lastTap = 0;
      function reset() {
        base.x = tmp.x = 0;
        base.y = tmp.y = 0;
        base.rot = tmp.rot = 0;
        base.scale = tmp.scale = 1;
      }

      target.addEventListener('pointerdown', onPointerDown, { passive: false });
      stage .addEventListener('pointermove', onPointerMove, { passive: false });
      stage .addEventListener('pointerup',   endPointer,     { passive: false });
      stage .addEventListener('pointercancel', endPointer,   { passive: false });
      stage .addEventListener('pointerleave',  endPointer,   { passive: false });
      stage .addEventListener('wheel', onWheel, { passive: false });

      stage.addEventListener('touchend', function(e) {
        const now = performance.now();
        if (now - lastTap < 300 && e.changedTouches.length === 1) reset();
        lastTap = now;
      }, { passive: false });

      window.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 'd') reset();
      });
      resetBtn.addEventListener('click', reset);

      // Fallback for Safari quirk where pointer events may be passive/scrolling:
      document.addEventListener('gesturestart', e => e.preventDefault());
      document.addEventListener('gesturechange', e => e.preventDefault());
      document.addEventListener('gestureend', e => e.preventDefault());
    })();
  </script>
</body>
</html>
