<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Gesture Tetris ‚Äî Hands Only</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* Keep the original simple look */
    :root { color-scheme: dark; }
    html,body { margin:0; padding:16px; background:#0b0f14; color:#e9f1fb; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    h1, .title { font-size: 16px; margin:0 0 10px 0; white-space: pre-wrap; }
    .muted { color:#9fb0c3; font-size: 13px; }
    .row { display:inline-flex; gap:8px; align-items:center; margin:8px 0; }
    button { background:#1b283a; color:#e9f1fb; border:1px solid #2b3c56; padding:6px 10px; border-radius:8px; cursor:pointer; }
    button:hover { background:#22324a; }
    #hud { display:inline-block; margin-left:8px; font-size:12px; color:#cde2ff; }
    /* Keep camera elements unobtrusive; you can show for debugging if you want */
    video, canvas { display:none; }
  </style>
</head>
<body>
  <!-- Keep the original headline style, just update the control hints -->
  <div class="title"># Gesture Tetris ‚Äî Hands Only: Head Pose ‚óÄ/‚ñ∂ Move, OK Rotate, Victory Drop</div>
  <div id="status" class="muted">Booting‚Ä¶</div>

  <div class="row">
    <button id="btnStart">Start Camera üì∑</button>
    <button id="btnHide">Hide</button>
    <span id="hud" aria-live="polite"></span>
  </div>

  <!-- Off-screen media elements (hidden to preserve original simple design) -->
  <video id="video" playsinline></video>
  <canvas id="overlay" width="640" height="480"></canvas>

  <!-- MediaPipe from CDN (FaceMesh for head pose, Hands for gestures) -->
  https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js</script>
  https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js</script>
  https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js</script>

  <script>
    /********************************************************************
     * Minimal configuration ‚Äî preserves your original page design
     * Map to your engine OR let it fall back to keyboard events.
     ********************************************************************/
    const CONFIG = {
      // If your engine exposes methods, put them here (optional but best):
      // Example:
      // left:   () => window.game.moveLeft(),
      // right:  () => window.game.moveRight(),
      // rotate: () => window.game.rotatePiece(), // or rotate()
      // drop:   () => window.game.hardDrop(),    // or drop()
      left:   null,
      right:  null,
      rotate: null,
      drop:   null,

      // Keyboard fallback (used when a direct call above is null)
      // Adjust to your engine‚Äôs bindings if needed.
      keys: {
        left:   "ArrowLeft",
        right:  "ArrowRight",
        rotate: "ArrowUp",
        drop:   "Space"
      },

      // Head-move feel
      head: { deadZone: 0.08, trigger: 0.15, firstDelay: 260, repeatEvery: 110, yawSmoothing: 0.30 }
    };

    /********************************************************************
     * Adapter: either call your functions or send the mapped key.
     ********************************************************************/
    function sendKey(code) {
      const e = new KeyboardEvent("keydown", { key: code, code, bubbles: true, cancelable: true });
      window.dispatchEvent(e); document.dispatchEvent(e);
    }
    const act = {
      left()   { if (CONFIG.left)   return CONFIG.left();   sendKey(CONFIG.keys.left); },
      right()  { if (CONFIG.right)  return CONFIG.right();  sendKey(CONFIG.keys.right); },
      rotate() { if (CONFIG.rotate) return CONFIG.rotate(); sendKey(CONFIG.keys.rotate); },
      drop()   { if (CONFIG.drop)   return CONFIG.drop();   sendKey(CONFIG.keys.drop); }
    };

    /********************************************************************
     * Minimal UI hooks (same as original)
     ********************************************************************/
    const $ = s => document.querySelector(s);
    const statusEl = $("#status");
    const hudEl = $("#hud");
    const videoEl = $("#video");
    const canvasEl = $("#overlay");
    const ctx = canvasEl.getContext("2d");
    let camera = null;

    $("#btnStart").addEventListener("click", startCamera);
    $("#btnHide").addEventListener("click", () => {
      // Hide only the helper HUD/status to keep original simplicity
      hudEl.style.display = "none";
      statusEl.style.display = "none";
    });

    function setStatus(t) { statusEl.textContent = t; }

    /********************************************************************
     * Head pose state (yaw) and repeat
     ********************************************************************/
    let calib = { centerX: 0.5, faceWidth: 0.25, has: false };
    let yawEMA = 0;
    let lastDir = 0, lastDirChangeAt = 0, lastRepeatAt = 0;

    // Simple calibration: hold neutral for ~1s after camera starts
    let calibSamples = [], calibUntil = 0;
    function startCalibration() {
      calib.has = false; calibSamples = []; calibUntil = performance.now() + 1000;
      setStatus("Calibrating‚Ä¶ hold head neutral for 1s");
    }
    function maybeDoCalibration(centerX, faceW) {
      const now = performance.now();
      if (calibUntil > 0) {
        calibSamples.push({ cx:centerX, fw:faceW });
        if (now > calibUntil) {
          const cx = calibSamples.map(s=>s.cx).sort((a,b)=>a-b)[Math.floor(calibSamples.length/2)];
          const fw = calibSamples.map(s=>s.fw).sort((a,b)=>a-b)[Math.floor(calibSamples.length/2)];
          calib.centerX = cx; calib.faceWidth = fw || 0.25; calib.has = true; calibUntil = 0;
          setStatus("Camera running");
        }
      }
    }

    /********************************************************************
     * MediaPipe: FaceMesh for head pose (left/right)
     ********************************************************************/
    const faceMesh = new FaceMesh.FaceMesh({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
    });
    faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
    faceMesh.onResults(onFaceResults);

    function onFaceResults(results) {
      const faces = results.multiFaceLandmarks;
      if (!faces || faces.length === 0) { hudEl.textContent = "No face"; return; }
      const lm = faces[0];
      const NOSE_TIP = 1, LEFT_EAR = 234, RIGHT_EAR = 454;

      const noseX = lm[NOSE_TIP].x;
      const leftX = lm[LEFT_EAR].x;
      const rightX = lm[RIGHT_EAR].x;
      const faceW = Math.max(1e-4, Math.abs(rightX - leftX));
      const centerX = (leftX + rightX) / 2;

      maybeDoCalibration(centerX, faceW);

      const cfg = CONFIG.head;
      const cx = calib.has ? calib.centerX : 0.5;
      const fw = calib.has ? calib.faceWidth : faceW;

      // Relative yaw proxy (nose offset normalized by face width)
      let yaw = (noseX - cx) / Math.max(1e-4, fw);
      yaw = Math.max(-0.8, Math.min(0.8, yaw));
      yawEMA = cfg.yawSmoothing * yaw + (1 - cfg.yawSmoothing) * yawEMA;

      hudEl.textContent = `Yaw ${yawEMA.toFixed(2)} ${Math.abs(yawEMA) < cfg.deadZone ? "" : (yawEMA>0?"‚Üí": "‚Üê")}`;
      handleHeadMove(yawEMA);
    }

    function handleHeadMove(yawVal) {
      const cfg = CONFIG.head;
      const now = performance.now();
      if (Math.abs(yawVal) < cfg.deadZone) { lastDir = 0; lastDirChangeAt = 0; return; }
      const dir = yawVal > 0 ? 1 : -1;
      if (Math.abs(yawVal) >= cfg.trigger) {
        if (dir !== lastDir) {
          if (dir > 0) act.right(); else act.left();
          lastDir = dir; lastDirChangeAt = now; lastRepeatAt = now;
        } else {
          if (now - lastDirChangeAt > cfg.firstDelay && now - lastRepeatAt > cfg.repeatEvery) {
            if (dir > 0) act.right(); else act.left();
            lastRepeatAt = now;
          }
        }
      }
    }

    /********************************************************************
     * MediaPipe: Hands for OK (rotate) + Victory (hard drop)
     ********************************************************************/
    const hands = new Hands.Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    hands.setOptions({ maxNumHands: 2, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6, modelComplexity: 1 });
    hands.onResults(onHandResults);

    // Gesture debouncing
    let okArmed = true, vArmed = true;
    const okCooldown = 280, vCooldown = 450;
    let lastOkAt = 0, lastVAt = 0;

    function onHandResults(results) {
      const handsLm = results.multiHandLandmarks || [];
      const handedness = results.multiHandedness || [];

      for (let i = 0; i < handsLm.length; i++) {
        handleGestures(handsLm[i], handedness[i]?.label || "?");
      }
    }

    function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
    function isExtended(lm, tipIdx, pipIdx, slack=0.015){ return lm[tipIdx].y < lm[pipIdx].y - slack; }

    function handleGestures(lm, whichHand) {
      // Indices
      const THUMB_TIP = 4, INDEX_TIP = 8, MIDDLE_TIP = 12, RING_TIP = 16, PINKY_TIP = 20;
      const INDEX_PIP = 6, MIDDLE_PIP = 10, RING_PIP = 14, PINKY_PIP = 18;
      const INDEX_MCP = 5, PINKY_MCP = 17;

      const palmW = Math.max(1e-4, dist(lm[INDEX_MCP], lm[PINKY_MCP]));

      // OK ‚Üí rotate: thumb-index pinch + other three extended
      const pinch = dist(lm[THUMB_TIP], lm[INDEX_TIP]) / palmW < 0.35;
      const midExt = isExtended(lm, MIDDLE_TIP, MIDDLE_PIP);
      const ringExt = isExtended(lm, RING_TIP, RING_PIP);
      const pinkExt = isExtended(lm, PINKY_TIP, PINKY_PIP);
      const isOK = pinch && midExt && ringExt && pinkExt;

      // Victory ‚Üí drop: index & middle extended & separated; ring & pinky folded
      const idxExt = isExtended(lm, INDEX_TIP, INDEX_PIP);
      const sepIM = dist(lm[INDEX_TIP], lm[MIDDLE_TIP]) / palmW > 0.25;
      const ringFold = !isExtended(lm, RING_TIP, RING_PIP);
      const pinkFold = !isExtended(lm, PINKY_TIP, PINKY_PIP);
      const isV = idxExt && midExt && sepIM && ringFold && pinkFold;

      const now = performance.now();
      if (isOK && okArmed && now - lastOkAt > okCooldown) {
        act.rotate(); okArmed = false; lastOkAt = now; hudEl.textContent = "Rotate (OK)";
      } else if (!isOK && now - lastOkAt > okCooldown) {
        okArmed = true;
      }

      if (isV && vArmed && now - lastVAt > vCooldown) {
        act.drop(); vArmed = false; lastVAt = now; hudEl.textContent = "Hard Drop (‚úå)";
      } else if (!isV && now - lastVAt > vCooldown) {
        vArmed = true;
      }
    }

    /********************************************************************
     * Camera start ‚Äî minimal changes, keep same controls
     ********************************************************************/
    async function startCamera() {
      if (camera) return;
      setStatus("Starting camera‚Ä¶");
      camera = new Camera(videoEl, {
        onFrame: async () => {
          // send same frame to both models
          await faceMesh.send({ image: videoEl });
          await hands.send({ image: videoEl });
          // keep canvas clean (hidden by default)
          ctx.clearRect(0,0,canvasEl.width, canvasEl.height);
        },
        width: 640, height: 480
      });
      camera.start();
      setStatus("Camera running (press ‚ÄòC‚Äô to recalibrate)");
      startCalibration(); // auto calibration on start
    }

    // Optional: press 'C' anytime to recalibrate neutral head pose
    document.addEventListener("keydown", (e) => { if (e.key.toLowerCase() === "c") startCalibration(); });

    // Small convenience: try to detect a global game object to wire direct calls automatically.
    // (Safe no-op if nothing found; keeps your simple page intact)
    window.addEventListener("load", () => {
      const g = window.game || window.tetris || window.engine || window.Game || null;
      try {
        if (g) {
          if (!CONFIG.left   && typeof g.moveLeft   === "function") CONFIG.left   = () => g.moveLeft();
          if (!CONFIG.right  && typeof g.moveRight  === "function") CONFIG.right  = () => g.moveRight();
          if (!CONFIG.rotate && typeof g.rotatePiece=== "function") CONFIG.rotate = () => g.rotatePiece();
          if (!CONFIG.rotate && typeof g.rotate     === "function") CONFIG.rotate = () => g.rotate();
          if (!CONFIG.drop   && typeof g.hardDrop   === "function") CONFIG.drop   = () => g.hardDrop();
          if (!CONFIG.drop   && typeof g.drop       === "function") CONFIG.drop   = () => g.drop();
        }
      } catch (_) {}
    });
  </script>
</body>
</html>
