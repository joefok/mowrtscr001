<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Gesture Tetris — Head Move, Fist Rotate, Swipe Down Drop</title>

data:,
<style>
  :root { --tile: 30px; }
  *{box-sizing:border-box}
  body { margin:0; background:#111; color:#fff; font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
  canvas { width:100vw; height:80vh; background:#000; display:block; }
  video { position:fixed; bottom:56px; right:10px; width:128px; height:96px; border:2px solid #0ff; transform:scaleX(-1); }
  #diag { position:fixed; top:10px; left:10px; background:rgba(0,0,0,.65); padding:8px 12px; border-radius:8px; font-size:13px; max-width:92vw; white-space:pre-wrap; }
  #controls { position:fixed; right:10px; bottom:10px; display:flex; gap:8px; }
  button { background:#0b3d46; border:1px solid #0ff; color:#0ff; border-radius:6px; font-size:12px; padding:6px 10px; cursor:pointer; }
  button:hover { background:#0e4f5a; }
</style>
</head>
<body>
  <div id="diag">Booting…</div>
  <canvas id="tetris"></canvas>
  <video id="camera" autoplay playsinline muted></video>

  <div id="controls">
    <button id="startBtn" type="button" style="display:none">Start Camera</button>
    <button id="retryBtn" type="button" style="display:none">Retry Detectors</button>
    <button id="camToggle" type="button">📷 Hide</button>
  </div>

  <!-- Robust loader (loads libs in order, then starts app) -->
  <script>
    (function loader(){
      const diag = document.getElementById('diag');
      const log = (msg) => { diag.textContent = msg; console.log(msg.replace(/<[^>]+>/g,'')); };
      function add(src){
        return new Promise((resolve,reject)=>{
          const s=document.createElement('script');
          s.src=src; s.async=true; s.crossOrigin='anonymous'; s.referrerPolicy='no-referrer';
          s.onload=()=>resolve(src); s.onerror=()=>reject(new Error('Failed: '+src));
          document.head.appendChild(s);
        });
      }
      const webglSupported = () => {
        try { const c=document.createElement('canvas'); return !!(c.getContext('webgl2')||c.getContext('webgl')||c.getContext('experimental-webgl')); }
        catch { return false; }
      };
      async function boot(){
        try {
          log('Loading TensorFlow.js…');
          await add('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js');
          try {
            if (webglSupported()) { await tf.setBackend('webgl'); } else { await tf.setBackend('cpu'); }
          } catch { await tf.setBackend('cpu'); }
          await tf.ready();

          log('Loading detectors…');
          // Pose-detection (for MoveNet) – TFJS runtime
          await add('https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.js');
          // Hand-pose-detection (for MediaPipe Hands)
          await add('https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection@2.0.1/dist/hand-pose-detection.min.js');
          // Mediapipe runtimes (for Hands only). NOTE: Pose uses MoveNet TFJS -> no MP assets here
          await add('https://cdn.jsdelivr.net/npm/@mediapipe/hands');

          if (!window.poseDetection || !window.handPoseDetection) throw new Error('Detectors failed to load');

          log('Libraries ready. Initializing app…');
          setTimeout(()=>{ if (typeof startApp === 'function') startApp(); }, 0);
        } catch(e) {
          log('Loader error:\n' + (e?.message || e));
          console.error(e);
        }
      }
      boot();
    })();
  </script>

  <script>
    async function startApp(){
      const diag = document.getElementById('diag');
      const video = document.getElementById('camera');
      const camToggle = document.getElementById('camToggle');
      const startBtn = document.getElementById('startBtn');
      const retryBtn = document.getElementById('retryBtn');

      // ===== Tetris core =====
      const canvas = document.getElementById('tetris');
      const ctx = canvas.getContext('2d');
      const TILE=30,COLS=10,ROWS=20;
      canvas.width=COLS*TILE; canvas.height=ROWS*TILE;

      const COLORS=['#000','#00f0f0','#0000f0','#f0a000','#f0f000','#00f000','#a000f0','#f00000'];
      const SHAPES = {
        1:[[1,1,1,1]],
        2:[[2,0,0],[2,2,2]],
        3:[[0,0,3],[3,3,3]],
        4:[[4,4],[4,4]],
        5:[[0,5,5],[5,5,0]],
        6:[[0,6,0],[6,6,6]],
        7:[[7,7,0],[0,7,7]],
      };

      let board = Array.from({length:ROWS},()=>Array(COLS).fill(0));
      let bag=[]; function refillBag(){ bag=[1,2,3,4,5,6,7]; for(let i=bag.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [bag[i],bag[j]]=[bag[j],bag[i]]; } }
      function nextId(){ if(!bag.length) refillBag(); return bag.pop(); }

      let active=null;
      function spawn(){
        const id=nextId(); const m=SHAPES[id].map(r=>r.slice());
        active={id, matrix:m, x: Math.floor(COLS/2 - m[0].length/2), y:-2};
        if (collides(m, active.x, active.y)) gameOverRestart();
      }
      function collides(mat,ox,oy){
        for(let y=0;y<mat.length;y++)
          for(let x=0;x<mat[y].length;x++)
            if(mat[y][x]){
              const bx=ox+x, by=oy+y;
              if (bx<0||bx>=COLS||by>=ROWS) return true;
              if (by>=0 && board[by][bx]) return true;
            }
        return false;
      }
      function merge(){
        for(let y=0;y<active.matrix.length;y++)
          for(let x=0;x<active.matrix[y].length;x++)
            if(active.matrix[y][x] && active.y+y>=0) board[active.y+y][active.x+x] = active.matrix[y][x];
      }
      function clearLines(){
        for (let y=ROWS-1;y>=0;){
          if (board[y].every(v=>v)) { board.splice(y,1); board.unshift(Array(COLS).fill(0)); }
          else y--;
        }
      }
      function rotateCW(m){ const h=m.length,w=m[0].length; const r=Array.from({length:w},()=>Array(h).fill(0)); for(let y=0;y<h;y++) for(let x=0;x<w;x++) r[x][h-1-y]=m[y][x]; return r; }
      function tryRotate(){
        const r=rotateCW(active.matrix);
        const kicks=[0,-1,1,-2,2];
        for (const k of kicks){ if (!collides(r, active.x+k, active.y)){ active.matrix=r; active.x+=k; draw(); return true;} }
        return false;
      }
      function tryMove(dir){ if (!collides(active.matrix, active.x+dir, active.y)){ active.x+=dir; draw(); } }
      function hardDrop(){ while(!collides(active.matrix, active.x, active.y+1)) active.y++; lock(); }
      function lock(){
        const topOut = active.y < 0;
        merge();
        if (topOut){ draw(); gameOverRestart(); return; }
        clearLines();
        spawn(); draw();
      }
      function draw(){
        ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
        // board
        for (let y=0;y<ROWS;y++) for (let x=0;x<COLS;x++){
          const v=board[y][x]; if (!v) continue;
          ctx.fillStyle=COLORS[v]; ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
          ctx.strokeStyle='rgba(0,0,0,.35)'; ctx.strokeRect(x*TILE+.5,y*TILE+.5,TILE-1,TILE-1);
        }
        // active
        if (active) for (let y=0;y<active.matrix.length;y++) for (let x=0;x<active.matrix[y].length;x++){
          const v=active.matrix[y][x]; if (!v) continue;
          const by=active.y+y, bx=active.x+x; if (by<0) continue;
          ctx.fillStyle=COLORS[v]; ctx.fillRect(bx*TILE,by*TILE,TILE,TILE);
          ctx.strokeStyle='rgba(0,0,0,.35)'; ctx.strokeRect(bx*TILE+.5,by*TILE+.5,TILE-1,TILE-1);
        }
        // grid
        ctx.strokeStyle='rgba(255,255,255,.08)';
        for (let gx=1;gx<COLS;gx++){ ctx.beginPath(); ctx.moveTo(gx*TILE,0); ctx.lineTo(gx*TILE,canvas.height); ctx.stroke(); }
        for (let gy=1;gy<ROWS;gy++){ ctx.beginPath(); ctx.moveTo(0,gy*TILE); ctx.lineTo(canvas.width,gy*TILE); ctx.stroke(); }
      }
      function gameOverRestart(delay=800){
        setTimeout(()=>{
          board = Array.from({length:ROWS},()=>Array(COLS).fill(0));
          spawn(); draw();
        }, delay);
      }
      // gravity
      let lastFall = performance.now();
      const FALL_MS = 900;
      function step(now){
        if (now - lastFall >= FALL_MS){
          lastFall = now;
          if (!collides(active.matrix, active.x, active.y+1)) active.y++;
          else lock();
          draw();
        }
        requestAnimationFrame(step);
      }

      // ===== Camera boot with fallback =====
      async function startCamera(){
        try {
          diag.textContent = 'Requesting camera…';
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode:'user', width:{ideal:960}, height:{ideal:720} },
            audio: false
          });
          video.srcObject = stream;
          await new Promise(res=>{
            if (video.readyState >= 2) res();
            else video.onloadedmetadata = res;
          });
          try { await video.play(); } catch {}
          diag.textContent = 'Camera ready. Starting detectors…';
          return true;
        } catch(e) {
          diag.textContent = 'Camera error:\n' + (e?.name || '') + ' ' + (e?.message || e);
          console.error(e);
          startBtn.style.display = 'inline-block';
          return false;
        }
      }
      function setCamVisible(show){
        video.style.display = show ? 'block' : 'none';
        camToggle.textContent = show ? '📷 Hide' : '📷 Show';
      }
      let camVisible = true;
      setCamVisible(camVisible);
      camToggle.addEventListener('click', ()=>{ camVisible = !camVisible; setCamVisible(camVisible); });
      setTimeout(()=>{ camVisible=false; setCamVisible(camVisible); }, 5000);

      // ===== Detectors with timeouts & fallback =====
      let poseDetector=null, handDetector=null;
      function withTimeout(promise, ms, label){
        return Promise.race([
          promise,
          new Promise((_,reject)=> setTimeout(()=>reject(new Error(label+' timeout after '+ms+'ms')), ms))
        ]);
      }
      async function createPoseDetector(){
        // Use MoveNet TFJS (no Mediapipe assets)
        diag.textContent = 'Starting detectors… (Pose: MoveNet TFJS)';
        poseDetector = await withTimeout(
          poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, {
            modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
            enableSmoothing: true,
          }),
          8000, 'Pose detector'
        );
      }
      async function createHandDetector(){
        // Use MediaPipe Hands runtime (best landmarks)
        diag.textContent = 'Starting detectors… (Hands: MediaPipe)';
        handDetector = await withTimeout(
          handPoseDetection.createDetector(handPoseDetection.SupportedModels.MediaPipeHands, {
            runtime: 'mediapipe',
            modelType: 'lite',
            solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands',
          }),
          8000, 'Hands detector'
        );
      }

      async function startDetectors(){
        try {
          await createPoseDetector();
        } catch(e){
          diag.textContent = 'Pose init error:\n' + (e?.message || e) + '\nFalling back to head-only via MoveNet failed.';
          console.error(e);
          throw e; // pose is required (for head left/right); bail so user can retry
        }

        try {
          await createHandDetector();
          retryBtn.style.display = 'none';
        } catch(e){
          // Proceed head-only; show retry button
          diag.textContent = 'Hands init error:\n' + (e?.message || e) + '\nContinuing with head-only controls. You can retry loading Hands.';
          console.warn(e);
          retryBtn.style.display = 'inline-block';
          handDetector = null;
        }
      }

      // ===== Gesture logic =====
      // Head → left/right (nose drift against short-term average) with DAS/ARR feel
      let noseHistory = []; const NOSE_FRAMES = 5; const MOVE_THRESH_PX = 18;
      let heldDir = 0, nextMoveAt = 0; const DAS_MS = 220, ARR_MS = 70;

      // Hand → fist = rotate (cooldown), swipe down = hard drop (short time window)
      let lastRotate = 0; const ROTATE_COOLDOWN_MS = 350;
      const SWIPE_WINDOW_MS = 180; const SWIPE_THRESH_PX = 80;
      let yHistory = []; // {t,y}

      function smooth(values){ if(!values.length) return 0; return values.reduce((a,b)=>a+b,0)/values.length; }

      async function detect(){
        try {
          // Pose (head move)
          if (poseDetector){
            const poses = await poseDetector.estimatePoses(video,{flipHorizontal:true});
            if (poses.length){
              const nose = poses[0].keypoints.find(k=>k.name==='nose');
              if (nose && nose.x != null){
                noseHistory.push(nose.x);
                if (noseHistory.length > NOSE_FRAMES) noseHistory.shift();
                if (noseHistory.length >= 2){
                  const avg = smooth(noseHistory.slice(0,-1));
                  const dx = noseHistory[noseHistory.length-1] - avg;
                  const now = performance.now();
                  let dir = 0;
                  if (dx >  MOVE_THRESH_PX) dir = +1;
                  if (dx < -MOVE_THRESH_PX) dir = -1;

                  if (dir === 0){
                    heldDir = 0; nextMoveAt = 0;
                  } else if (dir !== heldDir){
                    tryMove(dir);
                    heldDir = dir; nextMoveAt = now + DAS_MS;
                  } else if (now >= nextMoveAt){
                    tryMove(heldDir); nextMoveAt = now + ARR_MS;
                  }
                }
              }
            }
          }

          // Hands (rotate/drop) — optional if handDetector available
          if (handDetector){
            const hands = await handDetector.estimateHands(video,{flipHorizontal:true});
            if (hands.length){
              const kps = hands[0].keypoints || [];
              const by = Object.fromEntries(kps.map(k=>[k.name,k]));
              const idxTip = by['index_finger_tip'];
              const midTip = by['middle_finger_tip'];
              const rngTip = by['ring_finger_tip'];
              const pnkTip = by['pinky_finger_tip'];
              const thTip  = by['thumb_tip'];

              if (idxTip && midTip && rngTip && pnkTip && thTip){
                // Fist: thumb-index small + other fingertips clustered
                const thumbIndex = Math.hypot(thTip.x-idxTip.x, thTip.y-idxTip.y);
                const cluster = (Math.hypot(midTip.x-rngTip.x, midTip.y-rngTip.y) + Math.hypot(rngTip.x-pnkTip.x, rngTip.y-pnkTip.y))/2;
                const fistLikely = thumbIndex < 40 && cluster < 35;

                const now = performance.now();
                if (fistLikely && (now - lastRotate > ROTATE_COOLDOWN_MS)){
                  tryRotate();
                  lastRotate = now;
                }

                // Swipe down on index fingertip
                const t = performance.now();
                yHistory.push({t, y: idxTip.y});
                while (yHistory.length && (t - yHistory[0].t) > SWIPE_WINDOW_MS) yHistory.shift();
                const minY = yHistory.reduce((m,p)=>Math.min(m,p.y), Infinity);
                if (idxTip.y - minY > SWIPE_THRESH_PX){
                  hardDrop();
                  yHistory.length = 0;
                }
              }
            } else {
              // no hands → decay swipe window
              const now = performance.now();
              yHistory = yHistory.filter(p => now - p.t <= SWIPE_WINDOW_MS);
            }
          }
        } catch(e){
          diag.textContent = 'Detection error:\n' + (e?.message || e);
          console.error(e);
        }
        requestAnimationFrame(detect);
      }

      // ===== Boot sequence =====
      function ready(){
        refillBag(); spawn(); draw();
        requestAnimationFrame(step);
        detect();
        diag.textContent = handDetector
          ? 'Ready. Head: move L/R • Fist: rotate • Swipe down: drop'
          : 'Ready (head-only). Fist/drop disabled (click “Retry Detectors”).';
      }

      async function startPipeline(){
        const ok = await startCamera();
        if (!ok) return;
        try {
          await startDetectors();
          ready();
        } catch(e){
          // Pose failed (critical)
          document.getElementById('retryBtn').style.display = 'inline-block';
          diag.textContent = 'Detectors failed:\n' + (e?.message || e);
        }
      }

      // Try to auto-start; if blocked, show Start button
      if (!('mediaDevices' in navigator) || !navigator.mediaDevices.getUserMedia){
        diag.textContent = 'getUserMedia not supported.\nUse HTTPS and a modern browser.';
        document.getElementById('startBtn').style.display = 'inline-block';
      } else {
        startPipeline().then(()=>{
          if (video.readyState < 2) document.getElementById('startBtn').style.display='inline-block';
        });
      }

      document.getElementById('startBtn').addEventListener('click', ()=> {
        document.getElementById('startBtn').style.display='none';
        startPipeline();
      });
      document.getElementById('retryBtn').addEventListener('click', async ()=>{
        diag.textContent = 'Retrying Hands detector…';
        try {
          await createHandDetector();
          document.getElementById('retryBtn').style.display = 'none';
          diag.textContent = 'Hands ready.';
        } catch(e){
          diag.textContent = 'Retry failed:\n' + (e?.message || e);
        }
      });
    }
  </script>
</body>
</html>
