<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Gesture Tetris â€” Head + Simple Hand Gestures</title>
<style>
  body { margin:0; background:#111; color:#fff; font-family:sans-serif; }
  canvas { width:100vw; height:80vh; background:#000; display:block; }
  video { position:fixed; bottom:10px; right:10px; width:120px; border:2px solid #0ff; transform:scaleX(-1); }
  #diag { position:fixed; top:10px; left:10px; background:rgba(0,0,0,.6); padding:8px; border-radius:6px; font-size:14px; }
</style>
</head>
<body<canvas id="tetris"></canvas>
<video id="camera" autoplay playsinline muted></video>

<script>
const TILE=30,COLS=10,ROWS=20;
const canvas=document.getElementById('tetris'),ctx=canvas.getContext('2d');
canvas.width=COLS*TILE;canvas.height=ROWS*TILE;
const diag=document.getElementById('diag');const video=document.getElementById('camera');

let board=Array.from({length:ROWS},()=>Array(COLS).fill(0));
const COLORS=['#000','#0ff','#00f','#f80','#ff0','#0f0','#a0f','#f00'];
const shapes={1:[[1,1,1,1]],2:[[2,0,0],[2,2,2]],3:[[0,0,3],[3,3,3]],4:[[4,4],[4,4]],5:[[0,5,5],[5,5,0]],6:[[0,6,0],[6,6,6]],7:[[7,7,0],[0,7,7]]};
let bag=[],active=null,score=0;
function refillBag(){bag=[1,2,3,4,5,6,7];for(let i=bag.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[bag[i],bag[j]]=[bag[j],bag[i]];}}
function nextId(){if(!bag.length)refillBag();return bag.pop();}
function spawn(){const id=nextId(),mat=shapes[id].map(r=>r.slice());active={id,matrix:mat,x:3,y:-2};if(collides(mat,active.x,active.y))reset();}
function collides(mat,ox,oy){for(let y=0;y<mat.length;y++)for(let x=0;x<mat[y].length;x++){if(mat[y][x]){const bx=ox+x,by=oy+y;if(bx<0||bx>=COLS||by>=ROWS||by>=0&&board[by][bx])return true;}}return false;}
function merge(){for(let y=0;y<active.matrix.length;y++)for(let x=0;x<active.matrix[y].length;x++){if(active.matrix[y][x]&&active.y+y>=0)board[active.y+y][active.x+x]=active.matrix[y][x];}}
function clearLines(){for(let y=ROWS-1;y>=0;){if(board[y].every(v=>v)){board.splice(y,1);board.unshift(Array(COLS).fill(0));score+=100;}else y--;}}
function reset(){board=Array.from({length:ROWS},()=>Array(COLS).fill(0));score=0;spawn();}
function rotate(){const m=active.matrix,h=m.length,w=m[0].length;const r=Array.from({length:w},()=>Array(h).fill(0));for(let y=0;y<h;y++)for(let x=0;x<w;x++)r[x][h-1-y]=m[y][x];if(!collides(r,active.x,active.y))active.matrix=r;}
function draw(){ctx.fillStyle='#000';ctx.fillRect(0,0,canvas.width,canvas.height);for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++){if(board[y][x]){ctx.fillStyle=COLORS[board[y][x]];ctx.fillRect(x*TILE,y*TILE,TILE,TILE);}}if(active){for(let y=0;y<active.matrix.length;y++)for(let x=0;x<active.matrix[y].length;x++){if(active.matrix[y][x]){ctx.fillStyle=COLORS[active.matrix[y][x]];ctx.fillRect((active.x+x)*TILE,(active.y+y)*TILE,TILE,TILE);}}}}
function drop(){while(!collides(active.matrix,active.x,active.y+1))active.y++;lock();}
function lock(){merge();clearLines();spawn();}
function step(){active.y++;if(collides(active.matrix,active.x,active.y)){active.y--;lock();}draw();setTimeout(step,500);}
spawn();draw();setTimeout(step,500);

// ===== Gesture Detection =====
let lastRotate=0,lastDrop=0;
let prevHeadX=null;
let prevHandY=null;
let swipeActive=false;

async function initDetector(){
  await tf.setBackend('cpu');await tf.ready();
  const handModel=handPoseDetection.SupportedModels.MediaPipeHands;
  const handDetector=await handPoseDetection.createDetector(handModel,{runtime:'mediapipe',modelType:'lite',solutionPath:'https://cdn.jsdelivr.net/npm/@mediapipe/hands'});
  const faceModel=poseDetection.SupportedModels.BlazePose;
  const faceDetector=await poseDetection.createDetector(faceModel,{runtime:'mediapipe',modelType:'lite',solutionPath:'https://cdn.jsdelivr.net/npm/@mediapipe/pose'});
  const stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:'user'},audio:false});
  video.srcObject=stream;await video.play();

  async function detect(){
    const poses=await faceDetector.estimatePoses(video,{flipHorizontal:true});
    if(poses.length){const nose=poses[0].keypoints.find(k=>k.name==='nose');if(nose){if(prevHeadX!==null){const dx=nose.x-prevHeadX;if(Math.abs(dx)>15){if(dx>0&&active.x<COLS-1&&!collides(active.matrix,active.x+1,active.y)){active.x++;}else if(dx<0&&active.x>0&&!collides(active.matrix,active.x-1,active.y)){active.x--;}}}prevHeadX=nose.x;}}
    const hands=await handDetector.estimateHands(video,{flipHorizontal:true});
    if(hands.length){const hand=hands[0];const wrist=hand.keypoints.find(k=>k.name==='wrist');const indexTip=hand.keypoints.find(k=>k.name==='index_finger_tip');const thumbTip=hand.keypoints.find(k=>k.name==='thumb_tip');if(wrist&&indexTip&&thumbTip){const fistDist=Math.hypot(indexTip.x-thumbTip.x,indexTip.y-thumbTip.y);if(fistDist<40&&performance.now()-lastRotate>600){rotate();lastRotate=performance.now();}if(prevHandY!==null){const dy=indexTip.y-prevHandY;if(dy>40&&!swipeActive&&performance.now()-lastDrop>800){drop();lastDrop=performance.now();swipeActive=true;}}prevHandY=indexTip.y;}}else{swipeActive=false;}
    draw();
    requestAnimationFrame(detect);
  }
  detect();
}
initDetector();
</script>
https://cdn.jsdelivr.net/npm/@tensorflow/tfjs</script>
https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection</script>
<script/cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection</script>
https://cdn.jsdelivr.net/npm/@mediapipe/hands</script>
https://cdn.jsdelivr.net/npm/@mediapipe/pose</script>
</body>
</html>
