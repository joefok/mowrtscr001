<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Gesture Tetris ‚Äî Head Pose Move, OK Rotate, ‚úåÔ∏è Drop</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: dark; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
           background:#0b0f14; color:#e9f1fb; }
    .panel { position: fixed; right: 12px; bottom: 12px; background: #0f1624cc; backdrop-filter: blur(6px);
             border:1px solid #203046; border-radius: 12px; padding: 10px; width: 320px; z-index: 99999; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
    button { background:#1b283a; color:#e9f1fb; border:1px solid #2b3c56; padding:6px 10px; border-radius:8px; cursor:pointer; }
    button:hover { background:#22324a; }
    .sub { font-size:12px; color:#9fb0c3; }
    .log { font-family: ui-monospace, Menlo, Consolas, monospace; font-size:12px; background:#0a0f18;
           border:1px solid #1f2a3a; border-radius:8px; padding:6px; height:110px; overflow:auto; margin-top:8px;}
    .hud { position: fixed; left: 12px; top: 12px; z-index: 99998; color:#fff; text-shadow:0 1px 2px rgba(0,0,0,.45); font-size:12px; }
    .pill { font-size:11px; opacity:.85; padding:2px 6px; border-radius:999px; background:#142034; border:1px solid #24344c; }
    video, canvas { display:none; } /* keep video/canvas off-screen; we only need the camera feed */
    .ok { color:#6ee7b7; } .v { color:#93c5fd; } .warn { color:#fca5a5; }
  </style>
</head>
<body>
  <!-- Minimal UI panel (can be hidden after testing) -->
  <div class="panel" id="panel">
    <div class="row" style="justify-content: space-between;">
      <strong>Gesture Controls</strong>
      <button id="btnHide">Hide</button>
    </div>
    <div class="sub" style="margin:6px 0 10px 0;">
      <span class="pill">Head ‚Üí ‚óÄ ‚ñ∂</span>
      <span class="pill">OK ‚Üí Rotate</span>
      <span class="pill">‚úå ‚Üí Hard Drop</span>
      &nbsp; <span class="pill">C to calibrate</span>
    </div>
    <div class="row">
      <button id="btnStart">Start Camera üì∑</button>
      <button id="btnCalib">Calibrate (C)</button>
      <span id="status" class="sub">Idle</span>
    </div>
    <div id="log" class="log"></div>
  </div>

  <!-- Heads-up text (yaw & last gesture) -->
  <div id="hud" class="hud"></div>

  <!-- Offscreen camera/overlay (kept hidden by CSS) -->
  <video id="video" playsinline></video>
  <canvas id="overlay" width="640" height="480"></canvas>

  <!-- MediaPipe (legacy solutions) from CDN -->
  https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js</script>
  https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js</script>
  https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js</script>
  https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js</script>

  <script>
    /********************************************************************
     * 1) CONFIG ‚Äî map to your engine, or use keyboard fallback.
     ********************************************************************/
    const GESTURE_TETRIS_CONFIG = {
      // A) Try direct calls (preferred for accuracy). Fill any methods you have:
      directCalls: {
        // Examples:
        // left:   () => window.game.moveLeft(),
        // right:  () => window.game.moveRight(),
        // rotate: () => window.game.rotate() || window.game.rotatePiece(),
        // drop:   () => window.game.hardDrop() || window.game.drop(),
        left:   null,
        right:  null,
        rotate: null,
        drop:   null
      },

      // B) Keyboard fallback: if your engine listens to keys, set the right ones here:
      keyMap: {
        left:   "ArrowLeft",
        right:  "ArrowRight",
        rotate: "ArrowUp",   // change to "KeyX" or "KeyZ" if your engine rotates with X/Z
        drop:   "Space"      // hard drop is often Space; change if needed
      },

      // C) Head-move repeat feel
      head: {
        deadZone: 0.08,    // no move inside ¬±deadZone
        trigger:  0.15,    // threshold to start moving
        firstDelay: 260,   // ms before auto-repeat
        repeatEvery: 110,  // ms between repeats
        yawSmoothing: 0.30 // 0..1 EMA smoothing
      },

      // D) UI: auto-start camera on load?
      autoStart: false
    };

    /********************************************************************
     * 2) UNIVERSAL ADAPTER ‚Äî sendAction() uses directCalls or key events.
     ********************************************************************/
    function dispatchKey(code) {
      const e = new KeyboardEvent("keydown", { key: code, code, bubbles: true, cancelable: true });
      window.dispatchEvent(e);
      document.dispatchEvent(e);
    }
    const sendAction = {
      left()   { if (GESTURE_TETRIS_CONFIG.directCalls.left)   return GESTURE_TETRIS_CONFIG.directCalls.left();   dispatchKey(GESTURE_TETRIS_CONFIG.keyMap.left);   },
      right()  { if (GESTURE_TETRIS_CONFIG.directCalls.right)  return GESTURE_TETRIS_CONFIG.directCalls.right();  dispatchKey(GESTURE_TETRIS_CONFIG.keyMap.right);  },
      rotate() { if (GESTURE_TETRIS_CONFIG.directCalls.rotate) return GESTURE_TETRIS_CONFIG.directCalls.rotate(); dispatchKey(GESTURE_TETRIS_CONFIG.keyMap.rotate); },
      drop()   { if (GESTURE_TETRIS_CONFIG.directCalls.drop)   return GESTURE_TETRIS_CONFIG.directCalls.drop();   dispatchKey(GESTURE_TETRIS_CONFIG.keyMap.drop);   }
    };

    // OPTIONAL: naive auto-detect common engines (you can delete if not needed)
    setTimeout(() => {
      const g = window.game || window.tetris || window.engine || window.Game || null;
      try {
        if (g) {
          if (!GESTURE_TETRIS_CONFIG.directCalls.left   && typeof g.moveLeft   === "function") GESTURE_TETRIS_CONFIG.directCalls.left   = () => g.moveLeft();
          if (!GESTURE_TETRIS_CONFIG.directCalls.right  && typeof g.moveRight  === "function") GESTURE_TETRIS_CONFIG.directCalls.right  = () => g.moveRight();
          if (!GESTURE_TETRIS_CONFIG.directCalls.rotate && typeof g.rotate     === "function") GESTURE_TETRIS_CONFIG.directCalls.rotate = () => g.rotate();
          if (!GESTURE_TETRIS_CONFIG.directCalls.rotate && typeof g.rotatePiece=== "function") GESTURE_TETRIS_CONFIG.directCalls.rotate = () => g.rotatePiece();
          if (!GESTURE_TETRIS_CONFIG.directCalls.drop   && typeof g.hardDrop   === "function") GESTURE_TETRIS_CONFIG.directCalls.drop   = () => g.hardDrop();
          if (!GESTURE_TETRIS_CONFIG.directCalls.drop   && typeof g.drop       === "function") GESTURE_TETRIS_CONFIG.directCalls.drop   = () => g.drop();
          console.log("[GestureTetris] autodetect:", GESTURE_TETRIS_CONFIG.directCalls);
        }
      } catch (e) {}
    }, 0);

    /********************************************************************
     * 3) UI helpers
     ********************************************************************/
    const $ = (q) => document.querySelector(q);
    const logEl = $("#log");
    const statusEl = $("#status");
    const hudEl = $("#hud");
    const videoEl = $("#video");
    const canvasEl = $("#overlay");
    const ctx = canvasEl.getContext("2d");

    function log(msg) {
      const t = new Date().toLocaleTimeString();
      if (logEl) logEl.textContent = `[${t}] ${msg}\n` + logEl.textContent;
      console.log("[GestureTetris]", msg);
    }
    function setStatus(s) { if (statusEl) statusEl.textContent = s; }

    /********************************************************************
     * 4) MediaPipe setup (FaceMesh + Hands)
     ********************************************************************/
    let camera = null;

    // Face pose state
    let calib = { centerX: 0.5, faceWidth: 0.25, has: false };
    let yawEMA = 0;
    let lastDir = 0, lastDirChangeAt = 0, lastRepeatAt = 0;

    // Gesture state
    let okArmed = true, vArmed = true;
    const okCooldown = 280, vCooldown = 450;
    let lastOkAt = 0, lastVAt = 0;

    const faceMesh = new FaceMesh.FaceMesh({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
    });
    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.6,
      minTrackingConfidence: 0.6
    });
    faceMesh.onResults(onFaceResults);

    const hands = new Hands.Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    hands.setOptions({
      maxNumHands: 2,
      minDetectionConfidence: 0.6,
      minTrackingConfidence: 0.6,
      modelComplexity: 1
    });
    hands.onResults(onHandResults);

    async function startCamera() {
      if (camera) return;
      setStatus("Starting camera‚Ä¶");
      camera = new Camera(videoEl, {
        onFrame: async () => {
          await faceMesh.send({ image: videoEl });
          await hands.send({ image: videoEl });
          // Keep canvas fresh for any debug drawing (not shown by default)
          ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
        },
        width: 640, height: 480
      });
      camera.start();
      setStatus("Camera running");
      log("Camera started");
    }

    document.getElementById("btnStart")?.addEventListener("click", startCamera);
    document.getElementById("btnCalib")?.addEventListener("click", () => requestCalibration());
    document.getElementById("btnHide")?.addEventListener("click", () => document.getElementById("panel").style.display = "none");
    document.addEventListener("keydown", (e) => { if (e.key.toLowerCase() === "c") requestCalibration(); });

    if (GESTURE_TETRIS_CONFIG.autoStart) window.addEventListener("load", startCamera);

    /********************************************************************
     * 5) Head pose ‚Üí left/right with repeat
     ********************************************************************/
    function requestCalibration() {
      calib.has = false;
      calibSamples = [];
      calibUntil = performance.now() + 900;
      log("Calibration started ‚Äî hold head neutral for ~1s");
    }
    let calibSamples = [], calibUntil = 0;

    function maybeDoCalibration(centerX, faceW) {
      const now = performance.now();
      if (calibUntil > 0) {
        calibSamples.push({ cx:centerX, fw:faceW });
        if (now > calibUntil) {
          const cx = calibSamples.map(s=>s.cx).sort((a,b)=>a-b)[Math.floor(calibSamples.length/2)];
          const fw = calibSamples.map(s=>s.fw).sort((a,b)=>a-b)[Math.floor(calibSamples.length/2)];
          calib.centerX = cx;
          calib.faceWidth = fw || 0.25;
          calib.has = true;
          calibUntil = 0;
          log(`Calibration done: centerX=${cx.toFixed(3)}, faceW=${fw.toFixed(3)}`);
        }
      }
    }

    function onFaceResults(results) {
      const faces = results.multiFaceLandmarks;
      if (!faces || faces.length === 0) {
        hudEl.innerHTML = `<span class="warn">No face</span>`;
        return;
      }
      const lm = faces[0];
      const NOSE_TIP = 1, LEFT_EAR = 234, RIGHT_EAR = 454;

      const noseX = lm[NOSE_TIP].x;
      const leftX = lm[LEFT_EAR].x;
      const rightX = lm[RIGHT_EAR].x;
      const faceW = Math.max(1e-4, Math.abs(rightX - leftX));
      const centerX = (leftX + rightX) / 2;

      maybeDoCalibration(centerX, faceW);

      const cfg = GESTURE_TETRIS_CONFIG.head;
      const cx = calib.has ? calib.centerX : 0.5;
      const fw = calib.has ? calib.faceWidth : faceW;
      let yaw = (noseX - cx) / Math.max(1e-4, fw);
      yaw = Math.max(-0.8, Math.min(0.8, yaw));
      yawEMA = cfg.yawSmoothing * yaw + (1 - cfg.yawSmoothing) * yawEMA;

      hudEl.innerHTML = `Yaw: ${yawEMA.toFixed(2)} ${Math.abs(yawEMA) < cfg.deadZone ? "(dead zone)" : (yawEMA>0?"‚Üí":"‚Üê")}`;

      handleHeadMove(yawEMA);
    }

    function handleHeadMove(yawVal) {
      const cfg = GESTURE_TETRIS_CONFIG.head;
      const now = performance.now();
      if (Math.abs(yawVal) < cfg.deadZone) {
        lastDir = 0; lastDirChangeAt = 0;
        return;
      }
      const dir = yawVal > 0 ? 1 : -1;
      if (Math.abs(yawVal) >= cfg.trigger) {
        if (dir !== lastDir) {
          if (dir > 0) sendAction.right(); else sendAction.left();
          lastDir = dir; lastDirChangeAt = now; lastRepeatAt = now;
        } else {
          const heldFor = now - lastDirChangeAt;
          if (heldFor > cfg.firstDelay && now - lastRepeatAt > cfg.repeatEvery) {
            if (dir > 0) sendAction.right(); else sendAction.left();
            lastRepeatAt = now;
          }
        }
      }
    }

    /********************************************************************
     * 6) Hands ‚Üí OK rotate, Victory hard drop
     ********************************************************************/
    function onHandResults(results) {
      const handsLm = results.multiHandLandmarks || [];
      const handedness = results.multiHandedness || [];

      for (let i = 0; i < handsLm.length; i++) {
        const lm = handsLm[i];
        handleGestures(lm, handedness[i]?.label || "?");
      }
    }

    // helpers
    function dist(a, b) { const dx = a.x - b.x, dy = a.y - b.y; return Math.hypot(dx, dy); }
    function isExtended(lm, tipIdx, pipIdx, slack = 0.015) { return lm[tipIdx].y < lm[pipIdx].y - slack; }

    function handleGestures(lm, whichHand) {
      const THUMB_TIP = 4, INDEX_TIP = 8, MIDDLE_TIP = 12, RING_TIP = 16, PINKY_TIP = 20;
      const INDEX_PIP = 6, MIDDLE_PIP = 10, RING_PIP = 14, PINKY_PIP = 18;
      const INDEX_MCP = 5, PINKY_MCP = 17;

      const palmW = Math.max(1e-4, dist(lm[INDEX_MCP], lm[PINKY_MCP]));

      // OK: thumb-index pinch + other three extended
      const pinch = dist(lm[THUMB_TIP], lm[INDEX_TIP]) / palmW < 0.35;
      const midExt = isExtended(lm, MIDDLE_TIP, MIDDLE_PIP);
      const ringExt = isExtended(lm, RING_TIP, RING_PIP);
      const pinkExt = isExtended(lm, PINKY_TIP, PINKY_PIP);
      const isOK = pinch && midExt && ringExt && pinkExt;

      // Victory: index & middle extended and separated; ring & pinky folded
      const idxExt = isExtended(lm, INDEX_TIP, INDEX_PIP);
      const sepIM = dist(lm[INDEX_TIP], lm[MIDDLE_TIP]) / palmW > 0.25;
      const ringFold = !isExtended(lm, RING_TIP, RING_PIP);
      const pinkFold = !isExtended(lm, PINKY_TIP, PINKY_PIP);
      const isV = idxExt && midExt && sepIM && ringFold && pinkFold;

      const now = performance.now();
      if (isOK && okArmed && now - lastOkAt > okCooldown) {
        sendAction.rotate();
        okArmed = false; lastOkAt = now;
        hudEl.innerHTML += ` &nbsp; <span class="ok">OK‚ÜíRotate</span>`;
        log("Gesture: OK (rotate)");
      } else if (!isOK && now - lastOkAt > okCooldown) {
        okArmed = true;
      }

      if (isV && vArmed && now - lastVAt > vCooldown) {
        sendAction.drop();
        vArmed = false; lastVAt = now;
        hudEl.innerHTML += ` &nbsp; <span class="v">‚úå‚ÜíDrop</span>`;
        log("Gesture: Victory (hard drop)");
      } else if (!isV && now - lastVAt > vCooldown) {
        vArmed = true;
      }
    }
  </script>
</body>
</html>
