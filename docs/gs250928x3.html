<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0"
  />
  <title>Gesture Tetris â€” SVG Gesture Icons</title>

  <!-- Prevent favicon 404 -->
  data:,
  https://cdn.jsdelivr.net
  https://unpkg.com

  <style>
    :root { --tile: 30px; }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      overflow: hidden;
      background: #111;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: #fff;
    }
    canvas {
      width: 100vw;
      height: 80vh;
      background: #000;
      display: block;
    }
    video {
      position: fixed;
      bottom: 96px; /* leave room for controls */
      right: 10px;
      width: 128px;
      height: 96px;
      border: 2px solid #0ff;
      z-index: 10;
      transform: scaleX(-1); /* mirror for natural control */
    }
    #diag {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,.6);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
      z-index: 10;
      max-width: 92vw;
      white-space: pre-wrap;
    }
    #hud {
      position: fixed;
      left: 10px;
      bottom: 10px;
      z-index: 10;
      background: rgba(0,0,0,.5);
      border: 1px solid rgba(255,255,255,.2);
      border-radius: 8px;
      padding: 8px 10px;
      font-size: 12px;
      max-width: 70vw;
    }
    #hud h4 { margin: 0 0 6px 0; font-size: 13px; }
    #hud .row {
      display: flex;
      gap: 12px;
      margin: 6px 0;
      flex-wrap: wrap;
      align-items: center;
    }
    #hud code { color: #9cf; }

    /* Controls */
    #controls { display: flex; gap: 10px; align-items: center; }
    #controls .label { opacity: .85; font-size: 12px; }
    #controls input[type="range"] { width: 140px; }
    #camToggle, #calibBtn {
      z-index: 11;
      background: #0b3d46;
      border: 1px solid #0ff;
      color: #0ff;
      border-radius: 6px;
      font-size: 12px;
      padding: 6px 10px;
      cursor: pointer;
      user-select: none;
    }
    #camToggle:hover, #calibBtn:hover { background: #0e4f5a; }
    #camToggle { position: fixed; right: 10px; bottom: 10px; }

    /* Gesture SVG Icons Row */
    #gestureIcons { display: flex; gap: 10px; align-items: center; }
    #gestureIcons .icon {
      width: 28px; height: 28px;
      opacity: 0.3;
      transition: transform .12s ease, opacity .12s ease, filter .12s ease;
    }
    #gestureIcons .icon.active {
      opacity: 1;
      transform: scale(1.12);
      filter: drop-shadow(0 0 6px rgba(0,255,255,0.75));
    }
    /* Color accents per action (stroke only) */
    .icon.move { stroke: #0ff; }
    .icon.rotate { stroke: #a0f; }
    .icon.drop { stroke: #f9a825; } /* amber */
    .icon path, .icon line, .icon polyline, .icon circle {
      stroke-width: 2.2; fill: none; stroke-linecap: round; stroke-linejoin: round;
    }
  </style>
</head>
<body>
  <!-- UI -->
  <div id="diag">Booting...</div>
  <canvas id="tetris"></canvas>
  <video id="camera" autoplay playsinline muted></video>

  <div id="hud">
    <h4>Gesture Tetris</h4>
    <div class="row">
      <div><b>Mode:</b> <span id="modeLabel">hand</span></div>
      <div><b>Score:</b> <span id="score">0</span></div>
      <div><b>Lines:</b> <span id="lines">0</span></div>
      <div><b>Pieces:</b> <span id="pieces">0</span></div>
    </div>

    <!-- Gesture icons (no help text, just visuals) -->
    <div class="row" id="gestureIcons">
      <!-- Move Left -->
      <svg id="iconLeft" class="icon move" viewBox="0 0 24 24" aria-hidden="true">
        <polyline points="14,6 8,12 14,18"></polyline>
        <line x1="8" y1="12" x2="20" y2="12"></line>
      </svg>
      <!-- Move Right -->
      <svg id="iconRight" class="icon move" viewBox="0 0 24 24" aria-hidden="true">
        <polyline points="10,6 16,12 10,18"></polyline>
        <line x1="4" y1="12" x2="16" y2="12"></line>
      </svg>
      <!-- Rotate -->
      <svg id="iconRotate" class="icon rotate" viewBox="0 0 24 24" aria-hidden="true">
        <polyline points="16,3 16,8 21,8"></polyline>
        <path d="M20,8a8,8 0 1 1 -2.4 -5.7"></path>
      </svg>
      <!-- Soft Drop -->
      <svg id="iconDrop" class="icon drop" viewBox="0 0 24 24" aria-hidden="true">
        <polyline points="6,10 12,16 18,10"></polyline>
        <line x1="12" y1="4" x2="12" y2="16"></line>
      </svg>
    </div>

    <!-- Controls -->
    <div class="row" id="controls">
      <div class="label"><b>Sensitivity</b></div>
      <input id="sens" type="range" min="0.2" max="0.8" step="0.05" value="0.35" />
      <span id="sensVal">0.35</span>
      <button id="calibBtn" type="button">ðŸŽ¯ Calibrate</button>
      <div class="label"><b>Keys:</b> <code>C</code> camera â€¢ <code>N</code> calibrate</div>
    </div>
  </div>

  <button id="camToggle" type="button">ðŸ“· Hide</button>

  <script>
    // ==================== CONFIG ====================
    const MODE = 'hand'; // 'hand' | 'pose'

    // Tetris movement feel (DAS/ARR)
    const DAS_MS = 220;  // initial delay before auto-repeat
    const ARR_MS = 70;   // auto-repeat rate while held
    const ROTATE_COOLDOWN_MS = 260; // rotate debounce

    // Smoothing
    const SMOOTH_FRAMES = 5; // moving average window

    // Gravity
    const fallMsBase = 900;  // slow default gravity
    const fallMsSoft = 250;  // while soft-dropping

    window.addEventListener('DOMContentLoaded', () => {
      const m = document.getElementById('modeLabel');
      if (m) m.textContent = MODE;
    });
  </script>

  <!-- ====== Loader with CDN fallback (CPU-safe) ====== -->
  <script>
    (function loadLibs(){
      const head = document.head;
      const diagEl = document.getElementById('diag');
      const log = (msg) => { if (diagEl) diagEl.innerHTML = msg; else console.log(msg.replace(/<[^>]+>/g,'')); };
      const add = (src) => new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = src; s.async = true; s.crossOrigin = 'anonymous'; s.referrerPolicy = 'no-referrer';
        s.onload = () => resolve(src);
        s.onerror = () => reject(new Error('Failed: ' + src));
        head.appendChild(s);
      });
      const webglSupported = () => {
        try {
          const c = document.createElement('canvas');
          return !!(c.getContext('webgl2') || c.getContext('webgl') || c.getContext('experimental-webgl'));
        } catch { return false; }
      };

      async function boot() {
        try {
          // ---- TFJS ----
          log('Loading TensorFlow.js...');
          try { await add("https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"); }
          catch { await add("https://unpkg.com/@tensorflow/tfjs@4.18.0/dist/tf.min.js"); }

          // Choose backend without WebGL spam
          if (webglSupported()) { try { await tf.setBackend('webgl'); } catch { await tf.setBackend('cpu'); } }
          else { await tf.setBackend('cpu'); }
          await tf.ready();

          // ---- Detection library per MODE ----
          if (MODE === 'hand') {
            log('Loading Hand Pose Detection...');
            try { await add("https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection@2.0.1/dist/hand-pose-detection.min.js"); }
            catch { await add("https://unpkg.com/@tensorflow-models/hand-pose-detection@2.0.1/dist/hand-pose-detection.min.js"); }

            // MediaPipe Hands runtime (assets)
            log('Loading MediaPipe Hands runtime...');
            try { await add("https://cdn.jsdelivr.net/npm/@mediapipe/hands@latest"); }
            catch { await add("https://unpkg.com/@mediapipe/hands@latest"); }
          } else {
            log('Loading Pose Detection (MoveNet)...');
            try { await add("https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.js"); }
            catch { await add("https://unpkg.com/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.js"); }
          }

          const tfOK  = !!window.tf;
          const libOK = MODE === 'hand' ? !!window.handPoseDetection : !!window.poseDetection;
          log(`TFJS: ${tfOK ? '<b>ok</b>' : '<i>missing</i>'} â€¢ ${MODE === 'hand' ? 'Hand-Pose' : 'Pose-Detection'}: ${libOK ? '<b>ok</b>' : '<i>missing</i>'}`);

          if (tfOK && libOK) setTimeout(() => { if (typeof startApp === 'function') startApp(); }, 0);
        } catch (e) {
          log('Loader error:<br>' + (e?.message || e));
          console.error(e);
        }
      }
      boot();
    })();
  </script>

  <!-- ====== App: Stacking Tetris + Easier Gestures + SVG Icons ====== -->
  <script>
    async function startApp() {
      // Safe DOM helpers
      const $ = (id) => document.getElementById(id);
      const setText = (el, text) => { if (el) el.textContent = text; };

      const diag = $('diag');
      const canvas = $('tetris');
      const ctx = canvas.getContext('2d');
      const video = $('camera');
      const camToggleBtn = $('camToggle');

      // HUD refs
      const scoreEl = $('score'), linesEl = $('lines'), piecesEl = $('pieces');
      const sensRange = $('sens'), sensVal = $('sensVal'), calibBtn = $('calibBtn');

      // SVG Icons
      const iconLeft = $('iconLeft');
      const iconRight = $('iconRight');
      const iconRotate = $('iconRotate');
      const iconDrop = $('iconDrop');
      const icons = { left: iconLeft, right: iconRight, rotate: iconRotate, drop: iconDrop };
      const setIcon = (name, active) => { const el = icons[name]; if (el) el.classList.toggle('active', !!active); };
      const flashIcon = (name, ms=140) => { setIcon(name, true); setTimeout(() => setIcon(name, false), ms); };

      // Board setup
      const TILE = 30, COLS = 10, ROWS = 20;
      canvas.width = COLS * TILE; canvas.height = ROWS * TILE;

      const COLORS = {
        0: '#000000', 1: '#00f0f0', 2: '#0000f0', 3: '#f0a000',
        4: '#f0f000', 5: '#00f000', 6: '#a000f0', 7: '#f00000',
      };

      const shapeById = (id) => ({
        1: [[1,1,1,1]],
        2: [[2,0,0],[2,2,2]],
        3: [[0,0,3],[3,3,3]],
        4: [[4,4],[4,4]],
        5: [[0,5,5],[5,5,0]],
        6: [[0,6,0],[6,6,6]],
        7: [[7,7,0],[0,7,7]],
      }[id].map(r => r.slice()));

      // 7-bag RNG
      let bag = [];
      function refillBag() {
        bag = [1,2,3,4,5,6,7];
        for (let i = bag.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [bag[i], bag[j]] = [bag[j], bag[i]];
        }
      }
      const nextId = () => { if (!bag.length) refillBag(); return bag.pop(); };

      // Game state
      const board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
      let active = null;
      let score = 0, lines = 0, pieces = 0;
      const updateHUD = () => { setText(scoreEl, score); setText(linesEl, lines); setText(piecesEl, pieces); };

      // Collisions
      function collides(mat, offX, offY) {
        for (let y = 0; y < mat.length; y++)
          for (let x = 0; x < mat[y].length; x++) {
            const v = mat[y][x]; if (!v) continue;
            const bx = offX + x, by = offY + y;
            if (bx < 0 || bx >= COLS || by >= ROWS) return true;
            if (by >= 0 && board[by][bx]) return true;
          }
        return false;
      }

      // Merge & clear
      function merge() {
        for (let y=0; y<active.matrix.length; y++)
          for (let x=0; x<active.matrix[y].length; x++) {
            const v = active.matrix[y][x];
            if (v && active.y + y >= 0) board[active.y + y][active.x + x] = v;
          }
      }
      function clearLines() {
        let cleared = 0;
        for (let y = ROWS - 1; y >= 0; ) {
          if (board[y].every(v => v !== 0)) {
            board.splice(y, 1);
            board.unshift(Array(COLS).fill(0));
            cleared++;
          } else y--;
        }
        if (cleared) {
          const table = {1:100, 2:300, 3:500, 4:800};
          score += table[cleared] || (cleared * 200);
          lines += cleared; updateHUD();
        }
      }

      // Spawn with auto-restart on Game Over
      let restarting = false;
      function gameOverRestart(delayMs = 1200) {
        if (restarting) return;
        restarting = true;

        // Stop soft drop & movement
        softDropActive = false; heldDir = 0; nextMoveAt = 0; dxHistory.length = 0;

        // Clear board & stats
        for (let r = 0; r < ROWS; r++) board[r].fill(0);
        score = 0; lines = 0; pieces = 0; updateHUD();

        // Clear active and redraw empty board
        active = null; draw();

        // Reset bag & gravity baseline
        bag.length = 0; refillBag();
        lastFallAt = performance.now();

        // Spawn again after delay
        setTimeout(() => {
          spawn(); draw();
          restarting = false;
          setText(diag, 'Ready.');
        }, delayMs);
      }

      function spawn() {
        const id = nextId();
        const mat = shapeById(id);
        const x = Math.floor(COLS / 2 - mat[0].length / 2);
        const y = -2;
        active = { id, matrix: mat, x, y };
        pieces++; updateHUD();
        if (collides(active.matrix, active.x, active.y)) {
          // Game over â†’ auto restart
          gameOverRestart();
          return;
        }
      }

      // Rotation + simple wall-kicks
      const rotateCW = (m) => {
        const h = m.length, w = m[0].length;
        const out = Array.from({length: w}, _ => Array(h).fill(0));
        for (let y=0;y<h;y++) for (let x=0;x<w;x++) out[x][h-1-y] = m[y][x];
        return out;
      };
      function tryRotate() {
        const rotated = rotateCW(active.matrix);
        const kicks = [0, -1, 1, -2, 2];
        for (const k of kicks) {
          if (!collides(rotated, active.x + k, active.y)) {
            active.matrix = rotated; active.x += k; draw(); return true;
          }
        }
        return false;
      }

      // Movement + lock
      function tryMove(dir) {
        if (!collides(active.matrix, active.x + dir, active.y)) {
          active.x += dir; draw();
        }
      }
      function lock() { merge(); clearLines(); spawn(); draw(); }

      // Draw
      function draw() {
        ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        // Board
        for (let y=0;y<ROWS;y++) for (let x=0;x<COLS;x++) {
          const v = board[y][x]; if (!v) continue;
          ctx.fillStyle = COLORS[v];
          ctx.fillRect(x*30, y*30, 30, 30);
          ctx.strokeStyle = 'rgba(0,0,0,0.35)';
          ctx.strokeRect(x*30+0.5, y*30+0.5, 29, 29);
        }
        // Active
        if (active) for (let y=0;y<active.matrix.length;y++) for (let x=0;x<active.matrix[y].length;x++) {
          const v = active.matrix[y][x]; if (!v) continue;
          const by = active.y + y, bx = active.x + x; if (by < 0) continue;
          ctx.fillStyle = COLORS[v];
          ctx.fillRect(bx*30, by*30, 30, 30);
          ctx.strokeStyle = 'rgba(0,0,0,0.35)';
          ctx.strokeRect(bx*30+0.5, by*30+0.5, 29, 29);
        }
        // Grid
        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        for (let gx=1; gx<COLS; gx++) { ctx.beginPath(); ctx.moveTo(gx*30, 0); ctx.lineTo(gx*30, canvas.height); ctx.stroke(); }
        for (let gy=1; gy<ROWS; gy++) { ctx.beginPath(); ctx.moveTo(0, gy*30); ctx.lineTo(canvas.width, gy*30); ctx.stroke(); }
      }

      // Gravity (time-based)
      let lastFallAt = performance.now();
      let softDropActive = false;
      function setSoftDrop(active) {
        softDropActive = !!active;
        setIcon('drop', softDropActive);
      }
      function step(now) {
        const interval = softDropActive ? fallMsSoft : fallMsBase;
        if (now - lastFallAt >= interval) {
          lastFallAt = now;
          if (!active) { requestAnimationFrame(step); return; }
          if (!collides(active.matrix, active.x, active.y + 1)) active.y++;
          else lock();
          draw();
        }
        requestAnimationFrame(step);
      }

      // ====== Easier movement: smoothing + deadzone + DAS/ARR ======
      let dxHistory = [];
      let neutralDx = 0;          // calibrated neutral offset
      let heldDir = 0;            // -1, 0, +1
      let nextMoveAt = 0;         // timestamp for next auto-repeat
      let lastRotate = 0;
      let pinchActive = false;

      // Sensitivity UI
      let sensitivity = parseFloat(sensRange?.value || '0.35');
      const updateSensitivityLabel = () => { if (sensVal) sensVal.textContent = sensitivity.toFixed(2); };
      updateSensitivityLabel();
      sensRange?.addEventListener('input', () => { sensitivity = parseFloat(sensRange.value); updateSensitivityLabel(); });

      function calibrateNeutral(currentDxAvg = 0) {
        neutralDx = currentDxAvg;
        const old = diag.textContent;
        diag.textContent = 'Neutral calibrated.';
        setTimeout(() => { diag.textContent = old; }, 800);
      }
      calibBtn?.addEventListener('click', () => calibrateNeutral(dxHistory.length ? dxHistory.reduce((a,b)=>a+b,0)/dxHistory.length : 0));
      window.addEventListener('keydown', (e) => {
        const k = e.key.toLowerCase();
        if (k === 'n') calibrateNeutral(dxHistory.length ? dxHistory.reduce((a,b)=>a+b,0)/dxHistory.length : 0);
      });

      // Camera
      setText(diag, 'Requesting camera...');
      if (!navigator.mediaDevices?.getUserMedia) {
        setText(diag, 'getUserMedia not supported. Use HTTPS / modern browser.');
        return;
      }
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
      video.srcObject = stream;
      await new Promise(r => { if (video.readyState >= 2) r(); else video.onloadeddata = r; });
      try { await video.play(); } catch {}

      // Detector
      let detector;
      if (MODE === 'hand') {
        setText(diag, 'Creating MediaPipe Hands detector...');
        const model = handPoseDetection.SupportedModels.MediaPipeHands;
        detector = await handPoseDetection.createDetector(model, {
          runtime: 'mediapipe',
          modelType: 'lite',
          solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands@latest',
        });
      } else {
        setText(diag, 'Creating MoveNet detector...');
        const model = poseDetection.SupportedModels.MoveNet;
        detector = await poseDetection.createDetector(model, {
          modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
          enableSmoothing: true,
        });
      }

      // Start game
      refillBag();
      spawn(); draw();
      requestAnimationFrame(step);
      setText(diag, 'Ready.');

      // Camera toggle (+ auto-hide after 5s)
      function setCamVisible(show) {
        video.style.display = show ? 'block' : 'none';
        camToggleBtn.textContent = show ? 'ðŸ“· Hide' : 'ðŸ“· Show';
      }
      let camVisible = true; setCamVisible(camVisible);
      setTimeout(() => { if (camVisible) { camVisible = false; setCamVisible(camVisible); } }, 5000);
      camToggleBtn.addEventListener('click', () => { camVisible = !camVisible; setCamVisible(camVisible); });
      window.addEventListener('keydown', (e) => { if (e.key.toLowerCase() === 'c') { camVisible = !camVisible; setCamVisible(camVisible); } });

      // ====== Detection loop with improved movement & icon feedback ======
      async function detect() {
        try {
          let dir = 0;  // -1, 0, +1
          let dropActive = false;
          let rotateIntent = false;

          if (MODE === 'hand') {
            const hands = await detector.estimateHands(video, { flipHorizontal: true });
            if (hands.length) {
              const kps = hands[0].keypoints || [];
              const byName = Object.fromEntries(kps.map(k => [k.name, k]));
              const wrist = byName['wrist'];
              const indexTip = byName['index_finger_tip'];
              const thumbTip = byName['thumb_tip'];
              const idxMcp = byName['index_finger_mcp'];
              const pnkMcp = byName['pinky_finger_mcp'];

              if (wrist && indexTip) {
                // Smoothed calibrated dx
                let dx = (indexTip.x - wrist.x);
                dxHistory.push(dx);
                if (dxHistory.length > SMOOTH_FRAMES) dxHistory.shift();
                const dxAvg = dxHistory.reduce((a,b)=>a+b,0) / dxHistory.length;
                const adj = dxAvg - neutralDx;

                // Adaptive threshold (palm width)
                let palmWidth = (idxMcp && pnkMcp) ? Math.hypot(idxMcp.x - pnkMcp.x, idxMcp.y - pnkMcp.y) : 100;
                const MOVE_THRESHOLD = palmWidth * sensitivity;

                if (adj > MOVE_THRESHOLD) dir = +1;
                else if (adj < -MOVE_THRESHOLD) dir = -1;
                else dir = 0;

                // Soft drop: index below wrist
                const dy = indexTip.y - wrist.y;
                dropActive = dy > (palmWidth * 0.6);
              }

              // Rotate on pinch
              if (thumbTip && indexTip) {
                const ddx = thumbTip.x - indexTip.x, ddy = thumbTip.y - indexTip.y;
                const dist = Math.hypot(ddx, ddy);
                const pinchThreshold = (idxMcp && pnkMcp)
                  ? Math.max(18, Math.hypot(idxMcp.x - pnkMcp.x, idxMcp.y - pnkMcp.y) * 0.22)
                  : 28;
                const pinchNow = dist < pinchThreshold;
                rotateIntent = pinchNow;
              }
            }
          } else {
            const poses = await detector.estimatePoses(video, { flipHorizontal: true });
            if (poses.length) {
              const kps = poses[0].keypoints || [];
              const byName = Object.fromEntries(kps.map(k => [k.name, k]));
              const conf = k => (k?.score ?? 0) > 0.5;
              const nose = byName['nose'];
              const lw = byName['left_wrist'], rw = byName['right_wrist'];
              const ls = byName['left_shoulder'], rs = byName['right_shoulder'];

              const wrist = conf(rw) ? rw : (conf(lw) ? lw : null);
              if (nose && conf(nose) && wrist) {
                const shoulderWidth = (conf(ls) && conf(rs)) ? Math.hypot(rs.x - ls.x, rs.y - ls.y) : 120;

                let dx = wrist.x - nose.x;
                dxHistory.push(dx);
                if (dxHistory.length > SMOOTH_FRAMES) dxHistory.shift();
                const dxAvg = dxHistory.reduce((a,b)=>a+b,0) / dxHistory.length;
                const adj = dxAvg - neutralDx;

                const MOVE_THRESHOLD = shoulderWidth * sensitivity;
                if (adj > MOVE_THRESHOLD) dir = +1;
                else if (adj < -MOVE_THRESHOLD) dir = -1;
                else dir = 0;

                const dy = wrist.y - nose.y;
                dropActive = dy > (shoulderWidth * 0.35);
                rotateIntent = dy < -(shoulderWidth * 0.18);
              }
            }
          }

          // Apply DAS/ARR, with icon pulses
          const now = performance.now();
          if (dir === 0) {
            heldDir = 0; nextMoveAt = 0;
          } else if (dir !== heldDir) {
            tryMove(dir);
            flashIcon(dir > 0 ? 'right' : 'left');
            heldDir = dir; nextMoveAt = now + DAS_MS;
          } else if (now >= nextMoveAt) {
            tryMove(heldDir);
            flashIcon(heldDir > 0 ? 'right' : 'left');
            nextMoveAt = now + ARR_MS;
          }

          // Soft drop icon (latched while active)
          setSoftDrop(!!dropActive);

          // Rotate icon pulse
          if (rotateIntent && (now - lastRotate > ROTATE_COOLDOWN_MS)) {
            if (tryRotate()) flashIcon('rotate', 180);
            lastRotate = now;
          }

        } catch (e) {
          setText(diag, 'Detection error: ' + (e?.message || e));
          console.error(e);
        }
        requestAnimationFrame(detect);
      }
      detect();
    }
  </script>
</body>
</html>
