<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Gesture Tetris ‚Äî Head Absolute Position (Auto Camera & Preview Hide)</title>
<style>
  :root{ --bg:#0b0f14; --panel:#121826; --text:#e8eefc; --muted:#7d8aa5; --accent:#50e3c2; --warn:#ffb020; }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  header{padding:10px 16px;border-bottom:1px solid #1f2a44;background:var(--panel);position:sticky;top:0;z-index:10}
  h1{font-size:16px;margin:0}
  main{display:grid;grid-template-columns:360px 1fr;gap:16px;padding:16px}
  @media (max-width: 960px){ main{grid-template-columns:1fr} }
  .panel{background:var(--panel);border:1px solid #1f2a44;border-radius:10px;padding:12px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin:6px 0}
  button{cursor:pointer;background:#1d2a3f;color:var(--text);border:1px solid #2c3f67;border-radius:8px;padding:8px 10px}
  button.primary{background:#224d3f;border-color:#1d6f58}
  small{color:var(--muted)}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#132744;border:1px solid #27518a;color:#cde}
  .stack{display:flex;flex-direction:column;gap:6px}
  .stage{position:relative;width:360px;height:720px}
  canvas#game{width:360px;height:720px;background:#0e1524;border-radius:12px;border:1px solid #1f2a44}
  canvas#hud{position:absolute;left:0;top:0;width:360px;height:720px;pointer-events:none}
  video{max-width:100%;border-radius:10px;border:1px solid #1f2a44}
  .note{padding:8px;border:1px dashed #334d89;border-radius:8px;background:rgba(34,46,80,.35)}
  .kbd{font:12px/1.2 ui-monospace,Menlo,Consolas,monospace;background:#0f1526;border:1px solid #213066;border-radius:6px;padding:2px 6px}
  .hidden{display:none !important}
</style>
</head>
<body>
<header>
  <h1>Gesture Tetris ‚Äî <span class="pill">Head Absolute X ‚Üí Move</span> ‚Ä¢ <span class="pill">1 Hand Move ‚Üí Rotate</span> ‚Ä¢ <span class="pill">2 Hands Steady ‚Üí Drop</span> ‚Ä¢ <span class="pill">Auto‚ÄëRestart</span></h1>
</header>

<main>
  <!-- LEFT: Game + Video/Debug -->
  <section class="panel">
    <div class="stack">
      <div class="row">
        <label class="row"><input type="checkbox" id="showVideo"> Show camera</label>
        <label class="row"><input type="checkbox" id="showHud" checked> Show debug HUD</label>
        <button id="fallbackStart" class="primary hidden">üì∑ Tap to enable camera</button>
      </div>
      <small>Camera auto‚Äëstarts on load and preview auto‚Äëhides after <strong>5s</strong>. Detection keeps running in the background.</small>

      <div class="stage">
        <canvas id="game" width="360" height="720"></canvas>
        <canvas id="hud" width="360" height="720"></canvas>
      </div>
      <!-- Preview is mirrored for natural left/right control. -->
      <video id="cam" autoplay playsinline muted style="transform:scaleX(-1); display:none"></video>

      <div class="note">
        <strong>Keyboard fallback:</strong>
        <span class="kbd">‚Üê</span>/<span class="kbd">‚Üí</span> move,
        <span class="kbd">‚Üë</span> rotate,
        <span class="kbd">Space</span> drop,
        <span class="kbd">P</span> pause.
      </div>
    </div>
  </section>

  <!-- RIGHT: Live state -->
  <section class="panel">
    <div class="stack">
      <h3 style="margin:0">Live State</h3>
      <pre id="state" style="white-space:pre; font-family:ui-monospace,Menlo,Consolas,monospace; font-size:12px; background:#0f162a; border:1px solid #253a6a; border-radius:8px; padding:8px; min-height:120px"></pre>
    </div>
  </section>
</main>

<script type="module">
/* =========================================================
   MediaPipe Tasks (Face + Hand Landmarkers) ‚Äî via CDN
   ========================================================= */
import { FilesetResolver, FaceLandmarker, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest";

/* =========================================================
   Minimal TETRIS ENGINE with Auto‚ÄëRestart on Game Over
   ========================================================= */
const gameCanvas = document.getElementById('game');
const gctx = gameCanvas.getContext('2d');
const W = 10, H = 20, CELL = 36;
const COLORS = {0:'#0e1524', I:'#50e3c2', J:'#4aa3ff', L:'#ffb020', O:'#ffd166', S:'#2ee59d', T:'#c084fc', Z:'#ff4d6d'};
const SHAPES = {
  I:[[1,1,1,1]], J:[[1,0,0],[1,1,1]], L:[[0,0,1],[1,1,1]],
  O:[[1,1],[1,1]], S:[[0,1,1],[1,1,0]], T:[[0,1,0],[1,1,1]], Z:[[1,1,0],[0,1,1]]
};
const BAG = ()=>Object.keys(SHAPES).sort(()=>Math.random()-0.5);
function rotateMatrix(m){ const h=m.length,w=m[0].length; const r=Array.from({length:w},()=>Array(h).fill(0)); for(let y=0;y<h;y++)for(let x=0;x<w;x++) r[x][h-1-y]=m[y][x]; return r; }
function drawCell(x,y,id){ const px=x*CELL, py=y*CELL; gctx.fillStyle=id?COLORS[id]:COLORS[0]; gctx.fillRect(px,py,CELL-1,CELL-1); }
function banner(text){ gctx.save(); gctx.fillStyle="rgba(0,0,0,.55)"; gctx.fillRect(0,0,gameCanvas.width,gameCanvas.height);
  gctx.fillStyle="#fff"; gctx.font="bold 28px system-ui,Segoe UI,Roboto"; gctx.textAlign="center";
  gctx.fillText(text, gameCanvas.width/2, gameCanvas.height/2); gctx.restore(); }
class Tetris {
  constructor(){ this.reset(); }
  reset(){
    this.board=Array.from({length:H},()=>Array(W).fill(0));
    this.score=0; this.lines=0; this.level=1;
    this.queue=BAG(); this.curr=null; this.holdLocked=false;
    this.dropInterval=800; this.acc=0; this.paused=false; this.gameOver=false;
    this.spawn();
  }
  spawn(){
    if(!this.queue.length) this.queue=BAG();
    const id=this.queue.pop();
    this.curr={id,shape:SHAPES[id].map(r=>r.slice()),x:3,y:0};
    if(this.collide(this.curr.x,this.curr.y,this.curr.shape)){
      this.gameOver=true; this.draw();
      setTimeout(()=>{ this.reset(); }, 1000); // auto‚Äërestart
      return;
    }
    this.holdLocked=false;
  }
  collide(px,py,shape){
    for(let y=0;y<shape.length;y++)for(let x=0;x<shape[0].length;x++){
      if(!shape[y][x]) continue;
      const nx=px+x, ny=py+y;
      if(nx<0||nx>=W||ny>=H) return true;
      if(ny>=0 && this.board[ny][nx]) return true;
    }
    return false;
  }
  lock(){
    const {x,y,shape,id}=this.curr;
    for(let j=0;j<shape.length;j++)
      for(let i=0;i<shape[0].length;i++)
        if(shape[j][i] && y+j>=0) this.board[y+j][x+i]=id;
    let cleared=0;
    for(let r=H-1;r>=0;r--){
      if(this.board[r].every(v=>v)){ this.board.splice(r,1); this.board.unshift(Array(W).fill(0)); cleared++; r++; }
    }
    if(cleared){ this.lines+=cleared; this.score+= [0,40,100,300,1200][cleared]*this.level; }
    this.level = 1 + Math.floor(this.lines/10);
    this.dropInterval = Math.max(120, 800 - (this.level-1)*60);
    this.spawn();
  }
  step(dt){ if(this.paused||this.gameOver) return; this.acc+=dt; if(this.acc>=this.dropInterval){ this.acc=0; this.down(); } }
  draw(){
    gctx.clearRect(0,0,gameCanvas.width,gameCanvas.height);
    for(let y=0;y<H;y++)for(let x=0;x<W;x++) drawCell(x,y,this.board[y][x]||0);
    if(this.curr){ const {x,y,shape,id}=this.curr; for(let j=0;j<shape.length;j++)for(let i=0;i<shape[0].length;i++) if(shape[j][i]) drawCell(x+i,y+j,id); }
    gctx.fillStyle="#9db4ff"; gctx.font="12px ui-monospace,Menlo,Consolas,monospace";
    gctx.fillText(`Score ${this.score}  Lines ${this.lines}  Lv ${this.level}`, 8, 16);
    if(this.paused) banner("PAUSED");
    if(this.gameOver) banner("GAME OVER ‚Äî Restarting‚Ä¶");
  }
  left(){ this.move(-1); }
  right(){ this.move(+1); }
  move(dx){ if(this.paused||this.gameOver) return; const n={...this.curr,x:this.curr.x+dx}; if(!this.collide(n.x,n.y,n.shape)) this.curr=n; }
  down(){ if(this.paused||this.gameOver) return; const n={...this.curr,y:this.curr.y+1}; if(!this.collide(n.x,n.y,n.shape)) this.curr=n; else this.lock(); }
  hardDrop(){ if(this.paused||this.gameOver) return; while(!this.collide(this.curr.x,this.curr.y+1,this.curr.shape)) this.curr.y++; this.lock(); this.score+=2; }
  rotateCW(){
    if(this.paused||this.gameOver) return;
    let r=rotateMatrix(this.curr.shape);
    const kicks=[[0,0],[1,0],[-1,0],[0,-1],[2,0],[-2,0]];
    for(const [kx,ky] of kicks){ if(!this.collide(this.curr.x+kx,this.curr.y+ky,r)){ this.curr.shape=r; this.curr.x+=kx; this.curr.y+=ky; return; } }
  }
  pauseToggle(){ this.paused=!this.paused; }
}
const game = new Tetris();

/* =========================================================
   Gesture Settings ‚Äî ABSOLUTE HEAD POSITION (no offset)
   ========================================================= */
const settings = {
  // Head absolute thresholds: normalized face X in [-1 .. +1]
  headAbsThreshold: 0.25,
  headDeadZoneAbs: 0.08,
  moveInitialDelay: 250,
  moveRepeat: 100,
  // 1-hand rotate (motion-based)
  oneHandSpeedThresh: 0.030,
  rotateCooldownMs: 300,
  // 2-hands steady ‚Üí drop
  twoHandsSteadySpeed: 0.010,
  twoHandsDwellMs: 650,
  // smoothing
  alphaFace: 0.6,
  alphaHand: 0.6
};

/* =========================================================
   Gesture State & Helpers
   ========================================================= */
const hud = document.getElementById('hud'); const hctx = hud.getContext('2d');
const stateEl = document.getElementById('state');
function ema(prev,v,a){ return prev*a + v*(1-a); }

const gesture = {
  // Face absolute normalized position
  faceX: 0, faceY: 0,
  lastFrameTs: performance.now(),
  moveDir: 0, nextMoveAt: 0,
  // Hands
  lastOneHandPos: null, lastRotateAt: 0,
  twoHandsSteadySince: 0,
  _last2: null // stores previous 2-hand positions for speed
};

function normXY(x,y,w,h){
  // Map pixel coords to [-1,+1], origin at center; y positive down; mirror x to match preview
  let nx = (x / w) * 2 - 1;
  let ny = (y / h) * 2 - 1;
  nx = -nx; // mirror so screen-left is negative
  return {nx, ny};
}
function faceCenterFromLandmarks(lms){
  // Use face bounding box center for stability across devices
  let minX=+1e9, minY=+1e9, maxX=-1e9, maxY=-1e9;
  for(const p of lms){ if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; }
  return { cx:(minX+maxX)/2, cy:(minY+maxY)/2 }; // normalized [0..1]
}
function palmCenter(lm){
  const picks=[0,5,9,13,17]; let sx=0,sy=0;
  for(const i of picks){ sx+=lm[i].x; sy+=lm[i].y; }
  return { cx:sx/picks.length, cy:sy/picks.length };
}
function drawHUD(show){
  hctx.clearRect(0,0,hud.width,hud.height); if(!show) return;
  const midX=hud.width/2, midY=hud.height/2;
  // Head absolute bands
  const t = settings.headAbsThreshold*midX;
  const d = settings.headDeadZoneAbs*midX;
  hctx.fillStyle="rgba(0,255,0,.14)"; hctx.fillRect(midX - t, 0, 2, hud.height); hctx.fillRect(midX + t, 0, 2, hud.height);
  hctx.fillStyle="rgba(255,165,0,.14)"; hctx.fillRect(midX - d, 0, 2, hud.height); hctx.fillRect(midX + d, 0, 2, hud.height);
  // Face dot
  const px = gesture.faceX*midX + midX;
  const py = gesture.faceY*midY + midY;
  hctx.beginPath(); hctx.arc(px,py,6,0,Math.PI*2); hctx.fillStyle="#50e3c2"; hctx.fill();
}

/* =========================================================
   Camera + Models (Front camera)
   ========================================================= */
const video = document.getElementById('cam');
const showVideoChk = document.getElementById('showVideo');
const fallbackBtn = document.getElementById('fallbackStart');
let camStream = null, faceLandmarker = null, handLandmarker = null;

async function initModels(){
  const fileset = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm");
  faceLandmarker = await FaceLandmarker.createFromOptions(fileset, {
    baseOptions: {
      modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task"
    },
    runningMode: "VIDEO",
    numFaces: 1,
    minFaceDetectionConfidence: 0.5,
    minFacePresenceConfidence: 0.5,
    minTrackingConfidence: 0.5
  });
  handLandmarker = await HandLandmarker.createFromOptions(fileset, {
    baseOptions: {
      modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task"
    },
    runningMode: "VIDEO",
    numHands: 2,
    minHandDetectionConfidence: 0.5,
    minHandPresenceConfidence: 0.5,
    minTrackingConfidence: 0.5
  });
}

async function startCamera(){
  if(camStream) return;
  camStream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode: { ideal: "user" }, width: { ideal: 640 }, height: { ideal: 480 } },
    audio: false
  });
  video.srcObject = camStream;
  await new Promise(r=> video.onloadedmetadata = r);
}

/* =========================================================
   Detection ‚Üí Mappings (Absolute Head X + Hand logic)
   ========================================================= */
function dispatch(events){
  for(const e of events){
    if(e.type==='move') (e.dir<0?game.left():game.right());
    if(e.type==='rotate') game.rotateCW();
    if(e.type==='drop') game.hardDrop();
  }
  const s = {
    faceX: gesture.faceX.toFixed(3),
    moveDir: gesture.moveDir,
    nextMoveInMs: Math.max(0, gesture.nextMoveAt - performance.now()).toFixed(0)
  };
  stateEl.textContent = JSON.stringify(s,null,2);
}

async function detectLoop(){
  if(!camStream || !faceLandmarker || !handLandmarker){ requestAnimationFrame(detectLoop); return; }
  const now = performance.now();
  const dt = now - gesture.lastFrameTs;
  const fpsFactor = dt>0 ? (16.7 / dt) : 1; // normalize speeds to ~60fps

  // --- Face: absolute normalized position [-1..+1] ---
  const fRes = await faceLandmarker.detectForVideo(video, now);
  const allFaces = fRes?.faceLandmarks ?? [];
  if(allFaces.length){
    const { cx, cy } = faceCenterFromLandmarks(allFaces[0]); // normalized [0..1]
    const { nx, ny } = normXY(cx*video.videoWidth, cy*video.videoHeight, video.videoWidth, video.videoHeight);
    gesture.faceX = ema(gesture.faceX, nx, settings.alphaFace);
    gesture.faceY = ema(gesture.faceY, ny, settings.alphaFace);
  }

  // --- Hands ---
  const hRes = await handLandmarker.detectForVideo(video, now);
  const hands = (hRes?.landmarks ?? []).map(lm => lm.map(p => ({ x:p.x*video.videoWidth, y:p.y*video.videoHeight })));

  const events = [];

  // 1) HEAD ABSOLUTE X ‚Üí MOVE (repeat like keyboard)
  const pos = gesture.faceX; // [-1,+1]
  const left = pos < -settings.headAbsThreshold;
  const right = pos >  settings.headAbsThreshold;
  if(left || right){
    const dir = left ? -1 : +1;
    if(gesture.moveDir !== dir){
      gesture.moveDir = dir; events.push({type:'move', dir});
      gesture.nextMoveAt = now + settings.moveInitialDelay;
    } else if(now >= gesture.nextMoveAt){
      events.push({type:'move', dir}); gesture.nextMoveAt = now + settings.moveRepeat;
    }
  } else if (Math.abs(pos) <= settings.headDeadZoneAbs){
    gesture.moveDir = 0;
  }

  // 2) ANY 1 HAND MOVEMENT ‚Üí ROTATE (motion edge)
  if(hands.length === 1){
    const { cx, cy } = palmCenter(hands[0]);
    const { nx, ny } = normXY(cx, cy, video.videoWidth, video.videoHeight);
    if(gesture.lastOneHandPos){
      const dx = nx - gesture.lastOneHandPos.nx;
      const dy = ny - gesture.lastOneHandPos.ny;
      const speed = Math.hypot(dx, dy) * fpsFactor;
      if(speed > settings.oneHandSpeedThresh && (now - gesture.lastRotateAt) > settings.rotateCooldownMs){
        events.push({type:'rotate'}); gesture.lastRotateAt = now;
      }
    }
    gesture.lastOneHandPos = { nx, ny };
  } else {
    gesture.lastOneHandPos = null;
  }

  // 3) ANY 2 HANDS STEADY ‚Üí DROP (dwell)
  if(hands.length >= 2){
    const [A,B] = hands;
    const pcA = palmCenter(A), pcB = palmCenter(B);
    const nA = normXY(pcA.cx, pcA.cy, video.videoWidth, video.videoHeight);
    const nB = normXY(pcB.cx, pcB.cy, video.videoWidth, video.videoHeight);
    if(!gesture._last2) gesture._last2 = { nA, nB };
    const speedA = Math.hypot(nA.nx - gesture._last2.nA.nx, nA.ny - gesture._last2.nA.ny) * fpsFactor;
    const speedB = Math.hypot(nB.nx - gesture._last2.nB.nx, nB.ny - gesture._last2.nB.ny) * fpsFactor;
    const steady = (speedA < settings.twoHandsSteadySpeed) && (speedB < settings.twoHandsSteadySpeed);
    if(steady){
      if(!gesture.twoHandsSteadySince) gesture.twoHandsSteadySince = now;
      if(now - gesture.twoHandsSteadySince >= settings.twoHandsDwellMs){
        events.push({type:'drop'}); gesture.twoHandsSteadySince = 0;
      }
    } else {
      gesture.twoHandsSteadySince = 0;
    }
    gesture._last2 = { nA, nB };
  } else {
    gesture.twoHandsSteadySince = 0; gesture._last2 = null;
  }

  dispatch(events);
  drawHUD(document.getElementById('showHud').checked);

  gesture.lastFrameTs = now;
  requestAnimationFrame(detectLoop);
}

/* =========================================================
   UI & Auto‚Äëboot (auto camera start + 5s preview)
   ========================================================= */
const $ = (id)=>document.getElementById(id);
$('showVideo').onchange = (e)=>{ video.style.display = e.target.checked ? 'block' : 'none'; };
$('showHud').onchange = ()=> drawHUD($('showHud').checked);

// Auto‚Äëboot on page load. Show preview immediately, then hide after 5s.
// If permissions are blocked, reveal a fallback button.
async function bootCameraAndModels(){
  try{
    await startCamera();
    await initModels();

    // Show preview immediately
    showVideoChk.checked = true;
    video.style.display = 'block';

    // Hide after 5 seconds, keep detection running
    setTimeout(()=>{
      showVideoChk.checked = false;
      video.style.display = 'none';
    }, 5000);

    // Start detection loop
    requestAnimationFrame(detectLoop);
  }catch(err){
    console.error("Auto-start failed:", err);
    fallbackBtn.classList.remove('hidden');
  }
}
fallbackBtn.addEventListener('click', async ()=>{
  fallbackBtn.disabled = true;
  await bootCameraAndModels();
  fallbackBtn.classList.add('hidden');
  fallbackBtn.disabled = false;
});

window.addEventListener('DOMContentLoaded', bootCameraAndModels);

/* Keyboard fallback */
window.addEventListener('keydown', (ev)=>{
  if(ev.repeat) return;
  if(ev.key==='ArrowLeft') game.left();
  if(ev.key==='ArrowRight') game.right();
  if(ev.key==='ArrowUp') game.rotateCW();
  if(ev.code==='Space') game.hardDrop();
  if(ev.key.toLowerCase()==='p') game.pauseToggle();
});

/* Game loop */
let lastTS = performance.now();
function gameLoop(ts){ const dt = ts - lastTS; lastTS = ts; game.step(dt); game.draw(); requestAnimationFrame(gameLoop); }
requestAnimationFrame(gameLoop);
</script>
</body>
