<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Gesture Tetris â€” Stacking (CPU-safe)</title>

  <!-- Prevent favicon 404 -->
  data:,
  https://cdn.jsdelivr.net
  https://unpkg.com

  <style>
    :root { --tile: 30px; }
    body {
      margin: 0;
      overflow: hidden;
      background: #111;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: #fff;
    }
    canvas {
      width: 100vw;
      height: 80vh;
      background: #000;
      display: block;
    }
    video {
      position: fixed;
      bottom: 46px; /* leave room for controls button */
      right: 10px;
      width: 112px;
      height: 84px;
      border: 2px solid #0ff;
      z-index: 10;
      transform: scaleX(-1); /* mirror for natural control */
    }
    #diag {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,.6);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 14px;
      z-index: 10;
      max-width: 92vw;
      white-space: pre-wrap;
    }
    #hud {
      position: fixed;
      left: 10px;
      bottom: 10px;
      z-index: 10;
      background: rgba(0,0,0,.5);
      border: 1px solid rgba(255,255,255,.2);
      border-radius: 6px; padding: 8px 10px; font-size: 12px;
      max-width: 60vw;
    }
    #hud h4 { margin: 0 0 6px 0; font-size: 13px; }
    #hud .row { display: flex; gap: 12px; margin: 4px 0; flex-wrap: wrap; }
    #hud code { color: #9cf; }
    #camToggle {
      position: fixed;
      right: 10px;
      bottom: 10px;
      z-index: 11;
      background: #0b3d46;
      border: 1px solid #0ff;
      color: #0ff;
      border-radius: 6px;
      font-size: 12px;
      padding: 6px 10px;
      cursor: pointer;
      user-select: none;
    }
    #camToggle:hover { background: #0e4f5a; }
  </style>
</head>
<body>
  <!-- UI elements (if you remove any, the app will recreate them) -->
  <div id="diag">Booting...</div>
  <canvas id="tetris"></canvas>
  <video id="camera" autoplay playsinline muted></video>

  <div id="hud">
    <h4>Gesture Tetris</h4>
    <div class="row">
      <div><b>Mode:</b> <span id="modeLabel">hand</span></div>
      <div><b>Score:</b> <span id="score">0</span></div>
      <div><b>Lines:</b> <span id="lines">0</span></div>
      <div><b>Pieces:</b> <span id="pieces">0</span></div>
    </div>
    <div class="row">
      <div><b>Gestures:</b></div>
      <div>
        Move = left/right offset â€¢
        Rotate = <span id="rotateHint">Pinch (thumb+index)</span> â€¢
        Soft drop = <span id="dropHint">Index tip below wrist</span>
      </div>
    </div>
    <div class="row">
      <div><b>Keys:</b></div>
      <div><code>C</code> toggle camera</div>
    </div>
    <div class="row">
      <div><b>Last gesture:</b></div>
      <div id="lastGesture">â€”</div>
    </div>
  </div>

  <button id="camToggle" type="button">ðŸ“· Hide</button>

  <script>
    // ==================== CONFIG ====================
    // Choose control source: 'hand' (default) or 'pose'
    const MODE = 'hand'; // 'hand' | 'pose'

    // Movement tuning
    const MOVE_COOLDOWN_MS   = 200; // throttle horizontal moves
    const ROTATE_COOLDOWN_MS = 320; // rotation debounce

    // Hand mode thresholds
    const HAND_DX_THRESHOLD  = 30;  // index tip to wrist (px) for left/right
    const HAND_PINCH_DIST    = 35;  // thumb tip â†” index tip distance (px) for rotate
    const HAND_DROP_DY       = 40;  // index tip lower than wrist (px) => soft drop

    // Pose mode thresholds
    const POSE_DX_THRESHOLD  = 30;  // wrist â†” nose dx (px) for left/right
    const POSE_ROTATE_DY     = -20; // wrist above nose by at least 20px -> rotate
    const POSE_DROP_DY       = 40;  // wrist below nose by at least 40px -> soft drop

    // Game speed (slower base)
    let fallMsBase   = 900; // default gravity (slower)
    let fallMsSoft   = 250; // while soft-dropping

    // Update hints safely (in case HUD is altered)
    window.addEventListener('DOMContentLoaded', () => {
      const m = document.getElementById('modeLabel'); if (m) m.textContent = MODE;
      const r = document.getElementById('rotateHint');
      const d = document.getElementById('dropHint');
      if (MODE === 'pose') {
        if (r) r.textContent = 'Wrist above nose';
        if (d) d.textContent = 'Wrist below nose';
      }
    });
  </script>

  <!-- ====== Loader with CDN fallback (CPU-safe) ====== -->
  <script>
    (function loadLibs(){
      const head = document.head;
      const diagEl = document.getElementById('diag');
      const log = (msg) => { if (diagEl) diagEl.innerHTML = msg; else console.log(msg.replace(/<[^>]+>/g,'')); };
      const add = (src) => new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = src; s.async = true; s.crossOrigin = 'anonymous'; s.referrerPolicy = 'no-referrer';
        s.onload = () => resolve(src);
        s.onerror = () => reject(new Error('Failed: ' + src));
        head.appendChild(s);
      });
      const webglSupported = () => {
        try {
          const c = document.createElement('canvas');
          return !!(c.getContext('webgl2') || c.getContext('webgl') || c.getContext('experimental-webgl'));
        } catch { return false; }
      };

      async function boot() {
        try {
          // ---- TFJS ----
          log('Loading TensorFlow.js...');
          try { await add("https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"); }
          catch { await add("https://unpkg.com/@tensorflow/tfjs@4.18.0/dist/tf.min.js"); }

          // Choose backend without spamming WebGL errors
          if (webglSupported()) {
            try { await tf.setBackend('webgl'); } catch { await tf.setBackend('cpu'); }
          } else {
            await tf.setBackend('cpu'); // skip webgl entirely if unsupported
          }
          await tf.ready();

          // ---- Detection library per MODE ----
          if (MODE === 'hand') {
            log('Loading Hand Pose Detection...');
            try { await add("https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection@2.0.1/dist/hand-pose-detection.min.js"); }
            catch { await add("https://unpkg.com/@tensorflow-models/hand-pose-detection@2.0.1/dist/hand-pose-detection.min.js"); }

            // MediaPipe Hands runtime (assets)
            log('Loading MediaPipe Hands runtime...');
            try { await add("https://cdn.jsdelivr.net/npm/@mediapipe/hands@latest"); }
            catch { await add("https://unpkg.com/@mediapipe/hands@latest"); }
          } else {
            log('Loading Pose Detection (MoveNet)...');
            try { await add("https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.js"); }
            catch { await add("https://unpkg.com/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.js"); }
          }

          const tfOK  = !!window.tf;
          const libOK = MODE === 'hand' ? !!window.handPoseDetection : !!window.poseDetection;
          log(`TFJS: ${tfOK ? '<b>ok</b>' : '<i>missing</i>'} â€¢ ${MODE === 'hand' ? 'Hand-Pose' : 'Pose-Detection'}: ${libOK ? '<b>ok</b>' : '<i>missing</i>'}`);

          if (tfOK && libOK) {
            setTimeout(() => { if (typeof startApp === 'function') startApp(); }, 0);
          }
        } catch (e) {
          log('Loader error:<br>' + (e?.message || e));
          console.error(e);
        }
      }
      boot();
    })();
  </script>

  <!-- ====== App: Stacking Tetris + Gestures (safe DOM & CPU fallback) ====== -->
  <script>
    async function startApp() {
      // Safe DOM helpers
      const $ = (id) => document.getElementById(id);
      const setText = (el, text) => { if (el) el.textContent = text; };
      const ensure = (tag, id, parent = document.body, attrs = {}) => {
        let el = $(id);
        if (!el) {
          el = document.createElement(tag);
          el.id = id;
          Object.assign(el, attrs);
          parent.appendChild(el);
        }
        return el;
      };

      // Ensure required elements exist (prevents null errors)
      const diag = ensure('div', 'diag');
      const canvas = ensure('canvas', 'tetris');
      const video = ensure('video', 'camera', document.body, { autoplay: true, playsInline: true, muted: true });
      const hud   = ensure('div', 'hud');
      if (!$('#modeLabel')) {
        hud.innerHTML = `
          <h4>Gesture Tetris</h4>
          <div class="row">
            <div><b>Mode:</b> <span id="modeLabel">hand</span></div>
            <div><b>Score:</b> <span id="score">0</span></div>
            <div><b>Lines:</b> <span id="lines">0</span></div>
            <div><b>Pieces:</b> <span id="pieces">0</span></div>
          </div>
          <div class="row">
            <div><b>Gestures:</b></div>
            <div>
              Move = left/right offset â€¢
              Rotate = <span id="rotateHint">${MODE === 'hand' ? 'Pinch (thumb+index)' : 'Wrist above nose'}</span> â€¢
              Soft drop = <span id="dropHint">${MODE === 'hand' ? 'Index tip below wrist' : 'Wrist below nose'}</span>
            </div>
          </div>
          <div class="row">
            <div><b>Keys:</b></div>
            <div><code>C</code> toggle camera</div>
          </div>
          <div class="row">
            <div><b>Last gesture:</b></div>
            <div id="lastGesture">â€”</div>
          </div>
        `;
      }
      const camToggleBtn = ensure('button', 'camToggle', document.body, { type: 'button' });
      if (!camToggleBtn.textContent) camToggleBtn.textContent = 'ðŸ“· Hide';

      // HUD references
      const lastGestureEl = $('#lastGesture');
      const scoreEl = $('#score');
      const linesEl = $('#lines');
      const piecesEl = $('#pieces');
      const modeLabelEl = $('#modeLabel');

      // Mode label
      setText(modeLabelEl, MODE);

      // Board setup
      const ctx = canvas.getContext('2d');
      const TILE = 30, COLS = 10, ROWS = 20;
      canvas.width = COLS * TILE;
      canvas.height = ROWS * TILE;

      // Colors by piece id (1..7)
      const COLORS = {
        0: '#000000', 1: '#00f0f0', 2: '#0000f0', 3: '#f0a000',
        4: '#f0f000', 5: '#00f000', 6: '#a000f0', 7: '#f00000',
      };

      // Tetromino shapes
      function shapeById(id) {
        const map = {
          1: [[1,1,1,1]],                    // I
          2: [[2,0,0],[2,2,2]],              // J
          3: [[0,0,3],[3,3,3]],              // L
          4: [[4,4],[4,4]],                  // O
          5: [[0,5,5],[5,5,0]],              // S
          6: [[0,6,0],[6,6,6]],              // T
          7: [[7,7,0],[0,7,7]],              // Z
        };
        return map[id].map(r => r.slice());
      }

      // 7-bag randomizer
      let bag = [];
      function refillBag() {
        bag = [1,2,3,4,5,6,7];
        for (let i = bag.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [bag[i], bag[j]] = [bag[j], bag[i]];
        }
      }
      function nextId() { if (!bag.length) refillBag(); return bag.pop(); }

      // Game state
      const board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
      let active = null; // {id, matrix, x, y}
      let score = 0, lines = 0, pieces = 0;
      const updateHUD = () => { setText(scoreEl, score); setText(linesEl, lines); setText(piecesEl, pieces); };

      // Collisions
      function collides(mat, offX, offY) {
        for (let y = 0; y < mat.length; y++)
          for (let x = 0; x < mat[y].length; x++) {
            const v = mat[y][x]; if (!v) continue;
            const bx = offX + x, by = offY + y;
            if (bx < 0 || bx >= COLS || by >= ROWS) return true;
            if (by >= 0 && board[by][bx]) return true;
          }
        return false;
      }

      // Merge & clear
      function merge() {
        for (let y = 0; y < active.matrix.length; y++)
          for (let x = 0; x < active.matrix[y].length; x++) {
            const v = active.matrix[y][x];
            if (v && active.y + y >= 0) board[active.y + y][active.x + x] = v;
          }
      }
      function clearLines() {
        let cleared = 0;
        for (let y = ROWS - 1; y >= 0; ) {
          if (board[y].every(v => v !== 0)) {
            board.splice(y, 1);
            board.unshift(Array(COLS).fill(0));
            cleared++;
          } else y--;
        }
        if (cleared) {
          const table = {1:100, 2:300, 3:500, 4:800};
          score += table[cleared] || (cleared * 200);
          lines += cleared; updateHUD();
        }
      }

      // Spawn
      function spawn() {
        const id = nextId();
        const mat = shapeById(id);
        const x = Math.floor(COLS / 2 - mat[0].length / 2);
        const y = -2;
        active = { id, matrix: mat, x, y };
        pieces++; updateHUD();
        if (collides(active.matrix, active.x, active.y)) {
          // Game over: reset
          for (let r = 0; r < ROWS; r++) board[r].fill(0);
          score = 0; lines = 0; pieces = 0; updateHUD();
          setText(lastGestureEl, 'game-over (reset)');
        }
      }

      // Rotation + simple wall-kicks
      const rotateCW = (m) => {
        const h = m.length, w = m[0].length;
        const out = Array.from({length: w}, _ => Array(h).fill(0));
        for (let y=0;y<h;y++) for (let x=0;x<w;x++) out[x][h-1-y]=m[y][x];
        return out;
      };
      function tryRotate() {
        const rotated = rotateCW(active.matrix);
        const kicks = [0, -1, 1, -2, 2];
        for (const k of kicks) {
          if (!collides(rotated, active.x + k, active.y)) {
            active.matrix = rotated; active.x += k; draw(); return true;
          }
        }
        return false;
      }

      // Movement
      function tryMove(dir) {
        if (!collides(active.matrix, active.x + dir, active.y)) { active.x += dir; draw(); }
      }
      function lock() { merge(); clearLines(); spawn(); draw(); }

      // Draw
      function draw() {
        ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        // Board
        for (let y=0;y<ROWS;y++) for (let x=0;x<COLS;x++) {
          const v = board[y][x]; if (!v) continue;
          ctx.fillStyle = COLORS[v];
          ctx.fillRect(x*30, y*30, 30, 30);
          ctx.strokeStyle = 'rgba(0,0,0,0.35)';
          ctx.strokeRect(x*30+0.5, y*30+0.5, 29, 29);
        }
        // Active
        if (active) for (let y=0;y<active.matrix.length;y++) for (let x=0;x<active.matrix[y].length;x++) {
          const v = active.matrix[y][x]; if (!v) continue;
          const by = active.y + y, bx = active.x + x; if (by < 0) continue;
          ctx.fillStyle = COLORS[v];
          ctx.fillRect(bx*30, by*30, 30, 30);
          ctx.strokeStyle = 'rgba(0,0,0,0.35)';
          ctx.strokeRect(bx*30+0.5, by*30+0.5, 29, 29);
        }
        // Grid
        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        for (let gx=1; gx<COLS; gx++) { ctx.beginPath(); ctx.moveTo(gx*30, 0); ctx.lineTo(gx*30, canvas.height); ctx.stroke(); }
        for (let gy=1; gy<ROWS; gy++) { ctx.beginPath(); ctx.moveTo(0, gy*30); ctx.lineTo(canvas.width, gy*30); ctx.stroke(); }
      }

      // Gravity (time-based)
      let lastFallAt = performance.now();
      let softDropActive = false;
      function setSoftDrop(active) { softDropActive = !!active; setText(lastGestureEl, active ? 'soft-drop' : 'â€”'); }
      function step(now) {
        const interval = softDropActive ? fallMsSoft : fallMsBase;
        if (now - lastFallAt >= interval) {
          lastFallAt = now;
          if (!collides(active.matrix, active.x, active.y + 1)) active.y++;
          else lock();
          draw();
        }
        requestAnimationFrame(step);
      }

      // Gesture debouncing
      let lastMove = 0;
      let lastRotate = 0;
      let pinchActive = false;

      // Camera
      setText(diag, 'Requesting camera...');
      if (!navigator.mediaDevices?.getUserMedia) {
        setText(diag, 'getUserMedia not supported. Use HTTPS / modern browser.');
        return;
      }
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
      video.srcObject = stream;
      await new Promise(r => { if (video.readyState >= 2) r(); else video.onloadeddata = r; });
      try { await video.play(); } catch {}

      // Detector
      let detector;
      if (MODE === 'hand') {
        setText(diag, 'Creating MediaPipe Hands detector...');
        const model = handPoseDetection.SupportedModels.MediaPipeHands;
        detector = await handPoseDetection.createDetector(model, {
          runtime: 'mediapipe',
          modelType: 'lite',
          solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands@latest',
        });
      } else {
        setText(diag, 'Creating MoveNet detector...');
        const model = poseDetection.SupportedModels.MoveNet;
        detector = await poseDetection.createDetector(model, {
          modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
          enableSmoothing: true,
        });
      }

      // Start game
      spawn(); draw();
      requestAnimationFrame(step);
      setText(diag, MODE === 'hand'
        ? 'Ready (hand): Move=index vs wrist X, Rotate=pinch, Soft drop=index below wrist. Press C to hide camera.'
        : 'Ready (pose): Move=wrist vs nose X, Rotate=wrist above nose, Soft drop=wrist below nose. Press C to hide camera.'
      );

      // Camera toggle (safe)
      function setCamVisible(show) {
        video.style.display = show ? 'block' : 'none';
        camToggleBtn.textContent = show ? 'ðŸ“· Hide' : 'ðŸ“· Show';
      }
      let camVisible = true; setCamVisible(camVisible);
      camToggleBtn.addEventListener('click', () => { camVisible = !camVisible; setCamVisible(camVisible); });
      window.addEventListener('keydown', (e) => { if (e.key.toLowerCase() === 'c') { camVisible = !camVisible; setCamVisible(camVisible); } });

      // Detection loop
      async function detect() {
        try {
          if (MODE === 'hand') {
            const hands = await detector.estimateHands(video, { flipHorizontal: true });
            if (hands.length) {
              const kps = hands[0].keypoints || [];
              const byName = Object.fromEntries(kps.map(k => [k.name, k]));
              const wrist = byName['wrist'];
              const indexTip = byName['index_finger_tip'];
              const thumbTip = byName['thumb_tip'];

              if (wrist && indexTip) {
                // Move
                const dx = indexTip.x - wrist.x;
                const now = performance.now();
                if (now - lastMove > MOVE_COOLDOWN_MS) {
                  if (dx > HAND_DX_THRESHOLD) { tryMove(+1); lastMove = now; setText(lastGestureEl, 'move-right'); }
                  else if (dx < -HAND_DX_THRESHOLD) { tryMove(-1); lastMove = now; setText(lastGestureEl, 'move-left'); }
                }
                // Soft drop
                const dy = indexTip.y - wrist.y;
                setSoftDrop(dy > HAND_DROP_DY);
              } else setSoftDrop(false);

              // Rotate on pinch
              if (thumbTip && indexTip) {
                const ddx = thumbTip.x - indexTip.x, ddy = thumbTip.y - indexTip.y;
                const dist = Math.hypot(ddx, ddy);
                const pinchNow = dist < HAND_PINCH_DIST;
                const now = performance.now();
                if (pinchNow && !pinchActive && (now - lastRotate > ROTATE_COOLDOWN_MS)) {
                  pinchActive = true;
                  if (tryRotate()) setText(lastGestureEl, 'rotate');
                  lastRotate = now;
                } else if (!pinchNow && pinchActive) pinchActive = false;
              }
            } else setSoftDrop(false);
          } else {
            const poses = await detector.estimatePoses(video, { flipHorizontal: true });
            if (poses.length) {
              const kps = poses[0].keypoints || [];
              const byName = Object.fromEntries(kps.map(k => [k.name, k]));
              const nose = byName['nose'];
              const rw = byName['right_wrist'];
              const lw = byName['left_wrist'];
              const conf = k => (k?.score ?? 0) > 0.5;
              const wrist = conf(rw) ? rw : (conf(lw) ? lw : null);

              if (nose && conf(nose) && wrist) {
                const dx = wrist.x - nose.x;
                const dy = wrist.y - nose.y;
                const now = performance.now();

                if (now - lastMove > MOVE_COOLDOWN_MS) {
                  if (dx > POSE_DX_THRESHOLD) { tryMove(+1); lastMove = now; setText(lastGestureEl, 'move-right'); }
                  else if (dx < -POSE_DX_THRESHOLD) { tryMove(-1); lastMove = now; setText(lastGestureEl, 'move-left'); }
                }
                if (dy < POSE_ROTATE_DY && (now - lastRotate > ROTATE_COOLDOWN_MS)) {
                  if (tryRotate()) setText(lastGestureEl, 'rotate'); lastRotate = now;
                }
                setSoftDrop(dy > POSE_DROP_DY);
              } else setSoftDrop(false);
            } else setSoftDrop(false);
          }
        } catch (e) {
          setText(diag, 'Detection error: ' + (e?.message || e));
          console.error(e);
        }
        requestAnimationFrame(detect);
      }
      detect();
    }
  </script>
</body>
</html>
