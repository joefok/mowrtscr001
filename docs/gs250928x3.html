<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<!-- No pinch zooming; full-bleed safe-area on mobile -->
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
<title>Gesture Tetris â€” Head Lane Control (Responsive HUD, No Scrolling/Zoom)</title>
<style>
  :root{ --bg:#0b0f14; --panel:#121826; --text:#e8eefc; --accent:#50e3c2; --warn:#ffb020; --muted:#7d8aa5; }

  /* Full-screen, no scroll, no browser gestures */
  html,body{
    margin:0; height:100%;
    background:var(--bg); color:var(--text);
    overflow:hidden;               /* no scrolling */
    touch-action:none;             /* no pinch/double-tap zoom */
    overscroll-behavior:none;
    -webkit-user-select:none; user-select:none;
    -webkit-tap-highlight-color: transparent;
    -webkit-text-size-adjust:100%;
  }

  /* Full-screen stage: we scale+center this to fit any screen */
  #stage{
    position:fixed; left:0; top:0;
    width:360px; height:720px;     /* base logical size */
    transform-origin: 0 0;         /* we translate+scale from top-left */
  }

  canvas{
    position:absolute; left:0; top:0;
    width:360px; height:720px;     /* CSS size equals base; we scale container */
    display:block;
  }

  /* Pinned selfie preview in the small upper corner, shrinks after 5s */
  #cam{
    position:fixed;
    top:8px; right:8px;
    width:160px; aspect-ratio:4/3; height:auto;
    transform:scaleX(-1);          /* mirror for natural left/right */
    border-radius:8px; border:1px solid #2c3f67;
    box-shadow:0 4px 16px rgba(0,0,0,.35);
    z-index:9999; pointer-events:none;
    transition: width .3s ease, opacity .3s ease, border-radius .3s ease;
  }
  #cam.tiny{ width:28px; opacity:.35; border-radius:50%; }

  /* Fallback permission button */
  #fallbackStart{
    position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
    z-index:10000;
    background:#224d3f; border:1px solid #1d6f58; color:#e8eefc;
    padding:12px 16px; border-radius:10px; font:15px system-ui,Segoe UI,Roboto,sans-serif;
  }
  #fallbackStart.hidden{ display:none; }
</style>
</head>
<body>

<!-- Full-screen, responsive game stage (scaled by JS) -->
<div id="stage" aria-label="Game stage">
  <canvas id="game" width="360" height="720"></canvas>
  <canvas id="hud"  width="360" height="720" aria-hidden="true"></canvas>
</div>

<!-- Always-on pinned camera preview -->
<video id="cam" autoplay playsinline muted></video>

<!-- Fallback button (only shown if auto-start fails) -->
<button id="fallbackStart" class="hidden">ðŸ“· Tap to enable camera</button>

<script type="module">
/* =========================================================
   MediaPipe Tasks (Face + Hand Landmarkers) â€” via CDN
   ========================================================= */
import { FilesetResolver, FaceLandmarker, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest";

/* =========================================================
   Responsive, no-scroll scaling
   ========================================================= */
const BASE_W = 360, BASE_H = 720;
const stage = document.getElementById('stage');
function relayout(){
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  const s = Math.min(vw/BASE_W, vh/BASE_H);
  const tx = Math.round((vw - BASE_W*s)/2);
  const ty = Math.round((vh - BASE_H*s)/2);
  stage.style.transform = `translate(${tx}px, ${ty}px) scale(${s})`;
}
window.addEventListener('resize', relayout);
window.addEventListener('orientationchange', ()=> setTimeout(relayout, 200));

/* Block residual browser zoom gestures */
for (const ev of ['gesturestart','gesturechange','gestureend','dblclick']) {
  window.addEventListener(ev, e => e.preventDefault(), { passive:false });
}
document.addEventListener('touchmove', e => e.preventDefault(), { passive:false });

/* =========================================================
   Minimal TETRIS ENGINE with Autoâ€‘Restart on Game Over
   ========================================================= */
const gameCanvas = document.getElementById('game');
const gctx = gameCanvas.getContext('2d');
const W = 10, H = 20, CELL = 36;
const COLORS = {0:'#0e1524', I:'#50e3c2', J:'#4aa3ff', L:'#ffb020', O:'#ffd166', S:'#2ee59d', T:'#c084fc', Z:'#ff4d6d'};
const SHAPES = {
  I:[[1,1,1,1]], J:[[1,0,0],[1,1,1]], L:[[0,0,1],[1,1,1]],
  O:[[1,1],[1,1]], S:[[0,1,1],[1,1,0]], T:[[0,1,0],[1,1,1]], Z:[[1,1,0],[0,1,1]]
};
const BAG = ()=>Object.keys(SHAPES).sort(()=>Math.random()-0.5);
function rotateMatrix(m){ const h=m.length,w=m[0].length; const r=Array.from({length:w},()=>Array(h).fill(0)); for(let y=0;y<h;y++)for(let x=0;x<w;x++) r[x][h-1-y]=m[y][x]; return r; }
function drawCell(x,y,id){ const px=x*CELL, py=y*CELL; gctx.fillStyle=id?COLORS[id]:COLORS[0]; gctx.fillRect(px,py,CELL-1,CELL-1); }
function banner(text){ gctx.save(); gctx.fillStyle="rgba(0,0,0,.55)"; gctx.fillRect(0,0,gameCanvas.width,gameCanvas.height);
  gctx.fillStyle="#fff"; gctx.font="bold 28px system-ui,Segoe UI,Roboto"; gctx.textAlign="center";
  gctx.fillText(text, gameCanvas.width/2, gameCanvas.height/2); gctx.restore(); }

class Tetris {
  constructor(){ this.reset(); }
  reset(){
    this.board=Array.from({length:H},()=>Array(W).fill(0));
    this.score=0; this.lines=0; this.level=1;
    this.queue=BAG(); this.curr=null; this.holdLocked=false;
    this.dropInterval=800; this.acc=0; this.paused=false; this.gameOver=false;
    this.spawn();
  }
  spawn(){
    if(!this.queue.length) this.queue=BAG();
    const id=this.queue.pop();
    this.curr={id,shape:SHAPES[id].map(r=>r.slice()),x:3,y:0};
    if(this.collide(this.curr.x,this.curr.y,this.curr.shape)){
      this.gameOver=true; this.draw();
      setTimeout(()=>{ this.reset(); }, 1000); // auto-restart
      return;
    }
    this.holdLocked=false;
  }
  collide(px,py,shape){
    for(let y=0;y<shape.length;y++)for(let x=0;x<shape[0].length;x++){
      if(!shape[y][x]) continue;
      const nx=px+x, ny=py+y;
      if(nx<0||nx>=W||ny>=H) return true;
      if(ny>=0 && this.board[ny][nx]) return true;
    }
    return false;
  }
  lock(){
    const {x,y,shape,id}=this.curr;
    for(let j=0;j<shape.length;j++)
      for(let i=0;i<shape[0].length;i++)
        if(shape[j][i] && y+j>=0) this.board[y+j][x+i]=id;
    let cleared=0;
    for(let r=H-1;r>=0;r--){
      if(this.board[r].every(v=>v)){ this.board.splice(r,1); this.board.unshift(Array(W).fill(0)); cleared++; r++; }
    }
    if(cleared){ this.lines+=cleared; this.score+= [0,40,100,300,1200][cleared]*this.level; }
    this.level = 1 + Math.floor(this.lines/10);
    this.dropInterval = Math.max(120, 800 - (this.level-1)*60);
    this.spawn();
  }
  step(dt){ if(this.paused||this.gameOver) return; this.acc+=dt; if(this.acc>=this.dropInterval){ this.acc=0; this.down(); } }
  draw(){
    gctx.clearRect(0,0,gameCanvas.width,gameCanvas.height);
    for(let y=0;y<H;y++)for(let x=0;x<W;x++) drawCell(x,y,this.board[y][x]||0);
    if(this.curr){ const {x,y,shape,id}=this.curr; for(let j=0;j<shape.length;j++)for(let i=0;i<shape[0].length;i++) if(shape[j][i]) drawCell(x+i,y+j,id); }
    gctx.fillStyle="#9db4ff"; gctx.font="12px ui-monospace,Menlo,Consolas,monospace";
    gctx.fillText(`Score ${this.score}  Lines ${this.lines}  Lv ${this.level}`, 8, 16);
    if(this.paused) banner("PAUSED");
    if(this.gameOver) banner("GAME OVER â€” Restartingâ€¦");
  }
  left(){ this.move(-1); }
  right(){ this.move(+1); }
  move(dx){ if(this.paused||this.gameOver) return; const n={...this.curr,x:this.curr.x+dx}; if(!this.collide(n.x,n.y,n.shape)) this.curr=n; }
  down(){ if(this.paused||this.gameOver) return; const n={...this.curr,y:this.curr.y+1}; if(!this.collide(n.x,n.y,n.shape)) this.curr=n; else this.lock(); }
  hardDrop(){ if(this.paused||this.gameOver) return; while(!this.collide(this.curr.x,this.curr.y+1,this.curr.shape)) this.curr.y++; this.lock(); this.score+=2; }
  rotateCW(){
    if(this.paused||this.gameOver) return;
    let r=rotateMatrix(this.curr.shape);
    const kicks=[[0,0],[1,0],[-1,0],[0,-1],[2,0],[-2,0]];
    for(const [kx,ky] of kicks){ if(!this.collide(this.curr.x+kx,this.curr.y+ky,r)){ this.curr.shape=r; this.curr.x+=kx; this.curr.y+=ky; return; } }
  }
  pauseToggle(){ this.paused=!this.paused; }
}
const game = new Tetris();

/* =========================================================
   HUD (semi-transparent reminders & lane grid)
   ========================================================= */
const hud = document.getElementById('hud');
const hctx = hud.getContext('2d');
let hudOn = true;

const tips = []; // {text, until, alpha, anchor}

function pushTip(text, ms=5000, anchor='bottom'){
  tips.push({ text, until: performance.now() + ms, alpha: 0, anchor });
}
function drawRoundedRect(ctx, x, y, w, h, r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}
function drawHUD(){
  hctx.clearRect(0,0,hud.width,hud.height);
  if(!hudOn) return;

  // Lane grid & current lane highlight
  const laneWpx = hud.width / W;
  hctx.strokeStyle="rgba(255,255,255,.08)"; hctx.lineWidth=1;
  for(let i=0;i<=W;i++){
    const x = Math.round(i*laneWpx);
    hctx.beginPath(); hctx.moveTo(x,0); hctx.lineTo(x,hud.height); hctx.stroke();
  }
  hctx.fillStyle="rgba(80,227,194,.08)";
  hctx.fillRect(currentLane*laneWpx, 0, laneWpx, hud.height);

  // Reminders (semi-transparent)
  const now = performance.now();
  // stack messages vertically
  const active = tips.filter(t => t.until > now);
  active.forEach((t, idx) => {
    t.alpha = Math.min(1, t.alpha + 0.08); // fade-in
    const padX=12, padY=8;
    hctx.font = "14px system-ui,Segoe UI,Roboto,sans-serif";
    const textW = hctx.measureText(t.text).width;
    const boxW = Math.min(hud.width - 40, textW + padX*2);
    const boxH = 28;
    const x = Math.round((hud.width - boxW)/2);
    const y = t.anchor === 'top' ? (12 + idx*(boxH+8)) : (hud.height - (idx+1)*(boxH+8) - 12);

    hctx.globalAlpha = 0.55 * t.alpha;
    hctx.fillStyle = "#0b0f14";
    drawRoundedRect(hctx, x, y, boxW, boxH, 8);
    hctx.fill();

    hctx.globalAlpha = 0.85 * t.alpha;
    hctx.fillStyle = "#e8eefc";
    hctx.fillText(t.text, x + padX, y + boxH - padY);
    hctx.globalAlpha = 1;
  });

  // Face dot (for reference)
  const midX = hud.width/2, midY = hud.height/2;
  const px = (gesture.faceX * midX) + midX;
  const py = (gesture.faceY * midY) + midY;
  hctx.beginPath(); hctx.arc(px,py,5,0,Math.PI*2); hctx.fillStyle="#50e3c2"; hctx.fill();
}

/* =========================================================
   Gesture Settings â€” Lane Control (Head), Rotate/Drop (Hands)
   ========================================================= */
const settings = {
  laneHysteresis: 0.06,       // normalized margin to switch lanes
  oneHandSpeedThresh: 0.030,  // 1-hand motion â†’ rotate
  rotateCooldownMs: 300,
  twoHandsSteadySpeed: 0.010, // 2 hands steady â†’ drop
  twoHandsDwellMs: 650,
  alphaFace: 0.6,
  alphaHand: 0.6
};

/* =========================================================
   Gesture State & Helpers
   ========================================================= */
const video = document.getElementById('cam');
const fallbackBtn = document.getElementById('fallbackStart');

function ema(prev,v,a){ return prev*a + v*(1-a); }

const gesture = {
  faceX: 0, faceY: 0, lastFrameTs: performance.now(),
  lastOneHandPos: null, lastRotateAt: 0,
  twoHandsSteadySince: 0, _last2: null
};

let currentLane = Math.floor(W/2);

function normXY(x,y,w,h){
  let nx = (x / w) * 2 - 1;
  let ny = (y / h) * 2 - 1;
  nx = -nx; // mirror for natural left/right
  return {nx, ny};
}
function faceCenterFromLandmarks(lms){
  let minX=+1e9, minY=+1e9, maxX=-1e9, maxY=-1e9;
  for(const p of lms){ if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; }
  return { cx:(minX+maxX)/2, cy:(minY+maxY)/2 };
}
function palmCenter(lm){
  const picks=[0,5,9,13,17]; let sx=0,sy=0; for(const i of picks){ sx+=lm[i].x; sy+=lm[i].y; }
  return { cx:sx/picks.length, cy:sy/picks.length };
}

/* Lane mapping & snapping */
function laneFromHeadX(nx, prevLane){
  const laneW = 2 / W; // normalized width per lane over [-1..+1]
  if (prevLane == null) return Math.max(0, Math.min(W-1, Math.floor((nx + 1) / laneW)));
  const centerPrev = -1 + (prevLane + 0.5) * laneW;
  const margin = settings.laneHysteresis;
  if (nx > centerPrev + (laneW/2 + margin) && prevLane < W-1) return prevLane + 1;
  if (nx < centerPrev - (laneW/2 + margin) && prevLane > 0)   return prevLane - 1;
  return prevLane;
}
function nearestValidX(desiredX, pieceW, shape){
  let bestX = null, bestDist = Infinity;
  for (let x=0; x<=W-pieceW; x++){
    if (!game.collide(x, game.curr.y, shape)) {
      const center = x + Math.floor(pieceW/2);
      const desiredCenter = desiredX + Math.floor(pieceW/2);
      const d = Math.abs(center - desiredCenter);
      if (d < bestDist) { bestDist = d; bestX = x; }
    }
  }
  return bestX;
}
function snapPieceToLane(lane){
  if(!game.curr) return;
  const shape = game.curr.shape;
  const pieceW = shape[0].length;
  const desiredCenterCol = lane;
  let desiredX = desiredCenterCol - Math.floor(pieceW/2);
  desiredX = Math.max(0, Math.min(W - pieceW, desiredX));
  const validX = nearestValidX(desiredX, pieceW, shape);
  if (validX !== null && validX !== game.curr.x) {
    const test = {...game.curr, x: validX};
    if(!game.collide(test.x, test.y, test.shape)) game.curr = test;
  }
}

/* =========================================================
   Camera + Models (Front camera)
   ========================================================= */
let camStream = null, faceLandmarker = null, handLandmarker = null;

async function initModels(){
  const fileset = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm");
  faceLandmarker = await FaceLandmarker.createFromOptions(fileset, {
    baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task" },
    runningMode: "VIDEO", numFaces: 1,
    minFaceDetectionConfidence: 0.5, minFacePresenceConfidence: 0.5, minTrackingConfidence: 0.5
  });
  handLandmarker = await HandLandmarker.createFromOptions(fileset, {
    baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task" },
    runningMode: "VIDEO", numHands: 2,
    minHandDetectionConfidence: 0.5, minHandPresenceConfidence: 0.5, minTrackingConfidence: 0.5
  });
}
async function startCamera(){
  if(camStream) return;
  camStream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode: { ideal: "user" }, width: { ideal: 640 }, height: { ideal: 480 } },
    audio: false
  });
  video.srcObject = camStream;
  await new Promise(r=> video.onloadedmetadata = r);
}

/* =========================================================
   Detection â†’ Mappings (Head lane + Hand gestures)
   ========================================================= */
function dispatch(events){
  for(const e of events){
    if(e.type==='rotate') game.rotateCW();
    if(e.type==='drop')   game.hardDrop();
  }
}
async function detectLoop(){
  if(!camStream || !faceLandmarker || !handLandmarker){ requestAnimationFrame(detectLoop); return; }
  const now = performance.now();
  const dt = now - gesture.lastFrameTs;
  const fpsFactor = dt>0 ? (16.7 / dt) : 1;

  // Face
  const fRes = await faceLandmarker.detectForVideo(video, now);
  const allFaces = fRes?.faceLandmarks ?? [];
  if(allFaces.length){
    const { cx, cy } = faceCenterFromLandmarks(allFaces[0]);
    const { nx, ny } = normXY(cx*video.videoWidth, cy*video.videoHeight, video.videoWidth, video.videoHeight);
    gesture.faceX = ema(gesture.faceX, nx, settings.alphaFace);
    gesture.faceY = ema(gesture.faceY, ny, settings.alphaFace);

    // Lane & snap
    currentLane = laneFromHeadX(gesture.faceX, currentLane);
    snapPieceToLane(currentLane);
  }

  // Hands
  const hRes = await handLandmarker.detectForVideo(video, now);
  const hands = (hRes?.landmarks ?? []).map(lm => lm.map(p => ({ x:p.x*video.videoWidth, y:p.y*video.videoHeight })));

  const events = [];

  // 1 hand movement â†’ rotate (edge on speed)
  if(hands.length === 1){
    const { cx, cy } = palmCenter(hands[0]);
    const { nx, ny } = normXY(cx, cy, video.videoWidth, video.videoHeight);
    if(gesture.lastOneHandPos){
      const dx = nx - gesture.lastOneHandPos.nx;
      const dy = ny - gesture.lastOneHandPos.ny;
      const speed = Math.hypot(dx, dy) * fpsFactor;
      if(speed > settings.oneHandSpeedThresh && (now - gesture.lastRotateAt) > settings.rotateCooldownMs){
        events.push({type:'rotate'}); gesture.lastRotateAt = now;
      }
    }
    gesture.lastOneHandPos = { nx, ny };
  } else {
    gesture.lastOneHandPos = null;
  }

  // 2 hands steady â†’ drop (dwell)
  if(hands.length >= 2){
    const [A,B] = hands;
    const pcA = palmCenter(A), pcB = palmCenter(B);
    const nA = normXY(pcA.cx, pcA.cy, video.videoWidth, video.videoHeight);
    const nB = normXY(pcB.cx, pcB.cy, video.videoWidth, video.videoHeight);
    if(!gesture._last2) gesture._last2 = { nA, nB };
    const speedA = Math.hypot(nA.nx - gesture._last2.nA.nx, nA.ny - gesture._last2.nA.ny) * fpsFactor;
    const speedB = Math.hypot(nB.nx - gesture._last2.nB.nx, nB.ny - gesture._last2.nB.ny) * fpsFactor;
    const steady = (speedA < settings.twoHandsSteadySpeed) && (speedB < settings.twoHandsSteadySpeed);
    if(steady){
      if(!gesture.twoHandsSteadySince) gesture.twoHandsSteadySince = now;
      if(now - gesture.twoHandsSteadySince >= settings.twoHandsDwellMs){
        events.push({type:'drop'}); gesture.twoHandsSteadySince = 0;
      }
    } else {
      gesture.twoHandsSteadySince = 0;
    }
    gesture._last2 = { nA, nB };
  } else {
    gesture.twoHandsSteadySince = 0; gesture._last2 = null;
  }

  dispatch(events);
  drawHUD();

  gesture.lastFrameTs = now;
  requestAnimationFrame(detectLoop);
}

/* =========================================================
   Autoâ€‘boot (auto camera start; shrink preview after 5s)
   ========================================================= */
async function boot(){
  try{
    relayout(); // initial layout
    await startCamera();
    await initModels();

    // Show tips via HUD (semi-transparent, non-blocking)
    pushTip("Head â†” controls lane (snap to columns)", 6000, 'top');
    pushTip("Move 1 hand â†’ Rotate", 6000, 'top');
    pushTip("Hold 2 hands steady â†’ Drop", 6000, 'top');
    pushTip("Preview shrinks in 5s; detection stays active", 5000, 'bottom');

    // Shrink camera preview after 5s (keeps running)
    video.classList.remove('tiny');
    setTimeout(()=> video.classList.add('tiny'), 5000);

    requestAnimationFrame(detectLoop);
  }catch(err){
    console.error("Auto-start failed:", err);
    document.getElementById('fallbackStart').classList.remove('hidden');
    pushTip("Tap to enable camera", 8000, 'bottom');
  }
}
document.getElementById('fallbackStart').addEventListener('click', async (e)=>{
  e.currentTarget.disabled = true;
  await boot();
  e.currentTarget.classList.add('hidden');
  e.currentTarget.disabled = false;
});
window.addEventListener('DOMContentLoaded', boot);

/* =========================================================
   Game loop (render at base resolution; stage scales responsively)
   ========================================================= */
let lastTS = performance.now();
function gameLoop(ts){ const dt = ts - lastTS; lastTS = ts; game.step(dt); game.draw(); drawHUD(); requestAnimationFrame(gameLoop); }
requestAnimationFrame(gameLoop);

/* Keyboard fallback (optional) */
window.addEventListener('keydown', (ev)=>{
  if(ev.repeat) return;
  if(ev.key==='ArrowLeft') game.left();
  if(ev.key==='ArrowRight') game.right();
  if(ev.key==='ArrowUp') game.rotateCW();
  if(ev.code==='Space') game.hardDrop();
  if(ev.key.toLowerCase()==='p') game.pauseToggle();
  if(ev.key.toLowerCase()==='h') hudOn = !hudOn; // toggle HUD if needed
});
</script>
</body>
</html>
