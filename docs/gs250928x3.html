<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Gesture Tetris</title>

  <!-- (Optional) Small perf win -->
  https://cdn.jsdelivr.net
  https://unpkg.com

  <style>
    :root { --tile: 30px; }
    body {
      margin: 0;
      overflow: hidden;
      background: #111;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: #fff;
    }
    canvas {
      width: 100vw;
      height: 80vh;
      background: #000;
      display: block;
    }
    video {
      position: fixed;
      bottom: 46px; /* leave room for controls button */
      right: 10px;
      width: 112px;
      height: 84px;
      border: 2px solid #0ff;
      z-index: 10;
      transform: scaleX(-1); /* mirror for natural control */
    }
    #diag {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,.6);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 14px;
      z-index: 10;
      max-width: 92vw;
      white-space: pre-wrap;
    }
    #camToggle {
      position: fixed;
      right: 10px;
      bottom: 10px;
      z-index: 11;
      background: #0b3d46;
      border: 1px solid #0ff;
      color: #0ff;
      border-radius: 6px;
      font-size: 12px;
      padding: 6px 10px;
      cursor: pointer;
      user-select: none;
    }
    #camToggle:hover { background: #0e4f5a; }
    #legend {
      position: fixed; left: 10px; bottom: 10px; z-index: 10;
      background: rgba(0,0,0,.5);
      border: 1px solid rgba(255,255,255,.2);
      border-radius: 6px; padding: 6px 10px; font-size: 12px;
      max-width: 60vw;
    }
    code { color: #9cf; }
  </style>
</head>
<body>
  <!-- UI elements -->
  <div id="diag">Booting...</div>
  <canvas id="tetris"></canvas>
  <video id="camera" autoplay playsinline muted></video>
  <button id="camToggle" type="button">ðŸ“· Hide</button>
  <div id="legend">
    <div><b>Mode:</b> <span id="modeLabel">hand</span></div>
    <div><b>Gestures:</b>
      <ul style="margin:6px 0 0 18px;padding:0;">
        <li><b>Move</b>: left/right offset</li>
        <li><b>Rotate</b>: <span id="rotateHint">Pinch (thumb+index)</span></li>
        <li><b>Soft drop</b>: <span id="dropHint">Index tip below wrist</span></li>
      </ul>
    </div>
    <div><b>Keys:</b> <code>C</code> camera toggle</div>
    <div><b>Last gesture:</b> <span id="lastGesture">â€”</span></div>
  </div>

  <script>
    // ==================== CONFIG ====================
    // Choose control source: 'hand' (default) or 'pose'
    const MODE = 'hand'; // 'hand' | 'pose'
    document.getElementById('modeLabel').textContent = MODE;
    if (MODE === 'pose') {
      document.getElementById('rotateHint').textContent = 'Wrist above nose';
      document.getElementById('dropHint').textContent = 'Wrist below nose';
    }

    // Movement tuning
    const MOVE_COOLDOWN_MS   = 180; // throttle horizontal moves
    const ROTATE_COOLDOWN_MS = 280; // rotation debounce
    const HAND_DX_THRESHOLD  = 30;  // index tip to wrist (px) for left/right
    const HAND_PINCH_DIST    = 35;  // thumb tip â†” index tip distance (px) for rotate
    const HAND_DROP_DY       = 40;  // index tip lower than wrist (px) => soft drop

    const POSE_DX_THRESHOLD  = 30;  // wrist â†” nose dx (px) for left/right
    const POSE_ROTATE_DY     = -20; // wrist above nose by at least 20px -> rotate
    const POSE_DROP_DY       = 40;  // wrist below nose by at least 40px -> soft drop

    // ==================== LOADER ====================
    (function loadLibs(){
      const head = document.head;
      const diagEl = document.getElementById('diag');
      function log(msg) {
        if (diagEl) diagEl.innerHTML = msg;
        else console.log(msg.replace(/<[^>]+>/g,''));
      }
      function add(src) {
        return new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.src = src;
          s.async = true;
          s.crossOrigin = 'anonymous';
          s.referrerPolicy = 'no-referrer';
          s.onload = () => resolve(src);
          s.onerror = () => reject(new Error('Failed: ' + src));
          head.appendChild(s);
        });
      }

      async function boot() {
        try {
          // ---- TFJS ----
          log('Loading TensorFlow.js...');
          try { await add("https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"); }
          catch { await add("https://unpkg.com/@tensorflow/tfjs@4.18.0/dist/tf.min.js"); }

          // Backend: WebGL â†’ CPU fallback
          try { await tf.setBackend('webgl'); }
          catch { await tf.setBackend('cpu'); }
          await tf.ready();

          // ---- Detection library per MODE ----
          if (MODE === 'hand') {
            log('Loading Hand Pose Detection...');
            try { await add("https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection@2.0.1/dist/hand-pose-detection.min.js"); }
            catch { await add("https://unpkg.com/@tensorflow-models/hand-pose-detection@2.0.1/dist/hand-pose-detection.min.js"); }

            // MediaPipe Hands runtime (assets)
            log('Loading MediaPipe Hands runtime...');
            try { await add("https://cdn.jsdelivr.net/npm/@mediapipe/hands@latest"); }
            catch { await add("https://unpkg.com/@mediapipe/hands@latest"); }
          } else {
            log('Loading Pose Detection (MoveNet)...');
            try { await add("https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.js"); }
            catch { await add("https://unpkg.com/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.js"); }
          }

          // Sanity checks
          const tfOK  = !!window.tf;
          const libOK = MODE === 'hand'
            ? !!window.handPoseDetection
            : !!window.poseDetection;

          log(`TFJS: ${tfOK ? '<b>ok</b>' : '<i>missing</i>'} â€¢ ${MODE === 'hand' ? 'Hand-Pose' : 'Pose-Detection'}: ${libOK ? '<b>ok</b>' : '<i>missing</i>'}`);

          if (tfOK && libOK) {
            setTimeout(() => {
              if (typeof startApp === 'function') startApp();
              else log('Libraries loaded. Define <code>startApp()</code> to continue.');
            }, 0);
          }
        } catch (e) {
          log('Loader error:<br>' + (e?.message || e));
          console.error(e);
        }
      }
      boot();
    })();
  </script>

  <script>
    // ==================== APP ====================
    async function startApp() {
      const diag = document.getElementById('diag');
      const video = document.getElementById('camera');
      const canvas = document.getElementById('tetris');
      const ctx = canvas.getContext('2d');
      const lastGestureEl = document.getElementById('lastGesture');
      const camToggleBtn = document.getElementById('camToggle');

      // Board setup
      const TILE = 30, COLS = 10, ROWS = 20;
      canvas.width = COLS * TILE;
      canvas.height = ROWS * TILE;

      // Simple "T" piece and position
      let piece = [
        [1, 1, 1],
        [0, 1, 0],
      ];
      let pos = { x: 3, y: 0 };

      // Gesture debouncing
      let lastMove = 0;
      let lastRotate = 0;
      let pinchActive = false; // only rotate on pinch start
      let softDropActive = false;

      // Fall timing (switchable for soft drop)
      let fallMs = 500; // default
      let fallTimer = null;

      function startFallTimer() {
        if (fallTimer) clearInterval(fallTimer);
        fallTimer = setInterval(tick, fallMs);
      }

      function setSoftDrop(active) {
        if (active && !softDropActive) {
          softDropActive = true; fallMs = 120; startFallTimer();
          lastGestureEl.textContent = 'soft-drop';
        } else if (!active && softDropActive) {
          softDropActive = false; fallMs = 500; startFallTimer();
          lastGestureEl.textContent = 'â€”';
        }
      }

      // Piece rotation (clockwise)
      function rotateCW(mat) {
        const h = mat.length, w = mat[0].length;
        const out = Array.from({length: w}, _ => Array(h).fill(0));
        for (let y=0; y<h; y++) for (let x=0; x<w; x++) out[x][h-1-y] = mat[y][x];
        return out;
      }

      function clampX() {
        const maxX = COLS - piece[0].length;
        if (pos.x < 0) pos.x = 0;
        if (pos.x > maxX) pos.x = maxX;
      }
      function draw() {
        ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = 'cyan';
        for (let y = 0; y < piece.length; ++y) {
          for (let x = 0; x < piece[y].length; ++x) {
            if (piece[y][x]) {
              ctx.fillRect((pos.x + x) * TILE, (pos.y + y) * TILE, TILE, TILE);
            }
          }
        }

        // faint grid
        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        for (let x = 1; x < COLS; x++) {
          ctx.beginPath(); ctx.moveTo(x * TILE, 0); ctx.lineTo(x * TILE, canvas.height); ctx.stroke();
        }
        for (let y = 1; y < ROWS; y++) {
          ctx.beginPath(); ctx.moveTo(0, y * TILE); ctx.lineTo(canvas.width, y * TILE); ctx.stroke();
        }
      }
      function tick() {
        pos.y++;
        if (pos.y > ROWS - piece.length) pos.y = 0;
        draw();
      }

      // Camera setup
      diag.textContent = 'Requesting camera...';
      if (!navigator.mediaDevices?.getUserMedia) {
        diag.textContent = 'getUserMedia not supported. Use HTTPS / modern browser.';
        return;
      }
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
      video.srcObject = stream;
      await new Promise(r => {
        if (video.readyState >= 2) return r();
        video.onloadeddata = () => r();
      });
      try { await video.play(); } catch {}

      // Detector setup
      let detector;
      if (MODE === 'hand') {
        diag.textContent = 'Creating MediaPipe Hands detector...';
        const model = handPoseDetection.SupportedModels.MediaPipeHands;
        detector = await handPoseDetection.createDetector(model, {
          runtime: 'mediapipe',
          modelType: 'lite', // 'full'|'heavy' also available
          solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands@latest',
        });
      } else {
        diag.textContent = 'Creating MoveNet detector...';
        const model = poseDetection.SupportedModels.MoveNet;
        detector = await poseDetection.createDetector(model, {
          modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
          enableSmoothing: true,
        });
      }

      // Start game loop
      draw();
      startFallTimer();
      diag.textContent = MODE === 'hand'
        ? 'Ready (hand): Move = index vs wrist X, Rotate = pinch, Soft drop = index below wrist. Press C to hide camera.'
        : 'Ready (pose): Move = wrist vs nose X, Rotate = wrist above nose, Soft drop = wrist below nose. Press C to hide camera.';

      // Camera toggle
      function setCamVisible(show) {
        video.style.display = show ? 'block' : 'none';
        camToggleBtn.textContent = show ? 'ðŸ“· Hide' : 'ðŸ“· Show';
      }
      let camVisible = true;
      setCamVisible(camVisible);
      camToggleBtn.addEventListener('click', () => { camVisible = !camVisible; setCamVisible(camVisible); });
      window.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 'c') { camVisible = !camVisible; setCamVisible(camVisible); }
      });

      // Detection loop
      async function detect() {
        try {
          if (MODE === 'hand') {
            const hands = await detector.estimateHands(video, { flipHorizontal: true });
            if (hands.length > 0) {
              const kps = hands[0].keypoints || [];
              const byName = Object.fromEntries(kps.map(k => [k.name, k]));
              const wrist = byName['wrist'];
              const indexTip = byName['index_finger_tip'];
              const thumbTip = byName['thumb_tip'];

              if (wrist && indexTip) {
                // Horizontal move
                const dx = indexTip.x - wrist.x; // +right, -left (after flip)
                const now = performance.now();
                if (now - lastMove > MOVE_COOLDOWN_MS) {
                  if (dx > HAND_DX_THRESHOLD) { pos.x += 1; lastMove = now; clampX(); draw(); lastGestureEl.textContent = 'move-right'; }
                  else if (dx < -HAND_DX_THRESHOLD) { pos.x -= 1; lastMove = now; clampX(); draw(); lastGestureEl.textContent = 'move-left'; }
                }

                // Soft drop (index below wrist)
                const dy = indexTip.y - wrist.y;
                setSoftDrop(dy > HAND_DROP_DY);
              }

              // Rotate by pinch (thumb_tip ~ index_tip)
              if (thumbTip && indexTip) {
                const ddx = thumbTip.x - indexTip.x;
                const ddy = thumbTip.y - indexTip.y;
                const dist = Math.hypot(ddx, ddy);
                const pinchNow = dist < HAND_PINCH_DIST;
                const now = performance.now();

                if (pinchNow && !pinchActive && (now - lastRotate > ROTATE_COOLDOWN_MS)) {
                  pinchActive = true;
                  piece = rotateCW(piece);
                  clampX(); draw();
                  lastRotate = now;
                  lastGestureEl.textContent = 'rotate';
                } else if (!pinchNow && pinchActive) {
                  pinchActive = false; // reset so next pinch triggers again
                }
              }
            } else {
              setSoftDrop(false);
            }
          } else {
            const poses = await detector.estimatePoses(video, { flipHorizontal: true });
            if (poses.length) {
              const kps = poses[0].keypoints || [];
              const byName = Object.fromEntries(kps.map(k => [k.name, k]));
              const nose = byName['nose'];
              const rw = byName['right_wrist'];
              const lw = byName['left_wrist'];
              const conf = k => (k?.score ?? 0) > 0.5;
              const wrist = conf(rw) ? rw : (conf(lw) ? lw : null);

              if (nose && conf(nose) && wrist) {
                const dx = wrist.x - nose.x;
                const dy = wrist.y - nose.y;
                const now = performance.now();

                // Move
                if (now - lastMove > MOVE_COOLDOWN_MS) {
                  if (dx > POSE_DX_THRESHOLD) { pos.x += 1; lastMove = now; clampX(); draw(); lastGestureEl.textContent = 'move-right'; }
                  else if (dx < -POSE_DX_THRESHOLD) { pos.x -= 1; lastMove = now; clampX(); draw(); lastGestureEl.textContent = 'move-left'; }
                }

                // Rotate (wrist above nose) - dy negative and magnitude >= threshold
                if (dy < POSE_ROTATE_DY && (now - lastRotate > ROTATE_COOLDOWN_MS)) {
                  piece = rotateCW(piece);
                  clampX(); draw();
                  lastRotate = now;
                  lastGestureEl.textContent = 'rotate';
                }

                // Soft drop
                setSoftDrop(dy > POSE_DROP_DY);
              } else {
                setSoftDrop(false);
              }
            } else {
              setSoftDrop(false);
            }
          }
        } catch (e) {
          diag.innerHTML = 'Detection error:<br>' + (e?.message || e);
          console.error(e);
        }
        requestAnimationFrame(detect);
      }
      detect();
    }
  </script>
</body>
</html>
