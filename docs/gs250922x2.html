<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dino Jump — Head/Face Up/Down → High Jump (MoveNet, CDN Fallback & Diagnostics)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#f7f7f7; color:#222; }
    #game { display:block; margin:20px auto; border:2px solid #888; background:#fff; }
    #info  { text-align:center; margin-top:6px; }
    #status { display:inline-block; margin-bottom:6px; }
    #errorMsg { color:#c00; white-space:pre-wrap; max-width:800px; margin:6px auto; }
    #webcam { position:fixed; top:10px; right:10px; width:160px; border:2px solid #444; border-radius:4px; }
    #overlay { position:fixed; top:10px; right:10px; width:160px; pointer-events:auto; }
    #overlayTapHint { position:fixed; top:10px; right:10px; width:160px; text-align:center; color:#222; font-size:12px; pointer-events:none; }
    /* Diagnostics banner */
    #diag { position:fixed; left:10px; top:10px; background:#fff; border:1px solid #ccc; padding:6px 8px; font:12px monospace; border-radius:4px; z-index:9999; }
    #diag b { color:#0a0; }
    #diag i { color:#a00; }
  </style>
</head>
<body>

<div id="diag">Loading…</div>

<canvas id="game" width="600" height="200"></canvas>

<div id="info">
  <span id="status">
    Allow camera, then move your <strong>head/face up or down</strong> to jump (bigger move → higher jump).
  </span>
  <div id="errorMsg"></div>
</div>

<!-- Webcam preview + overlay -->
<video id="webcam" autoplay playsinline muted></video>
<canvas id="overlay"></canvas>
<div id="overlayTapHint">Tip: tap the preview or press Space/↑ to jump</div>

<!-- ====== Load TFJS & Pose Detection with automatic fallback ====== -->
<script>
  (function loadLibs(){
    const head = document.head;

    function add(src) {
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = src;
        s.onload = () => resolve(src);
        s.onerror = () => reject(new Error('Failed: ' + src));
        head.appendChild(s);
      });
    }

    async function boot() {
      const diag = (msg) => document.getElementById('diag').innerHTML = msg;

      // Try jsDelivr first, then fall back to unpkg if blocked.
      try {
        await add("https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js");
      } catch {
        await add("https://unpkg.com/@tensorflow/tfjs@4.18.0/dist/tf.min.js");
      }

      try {
        await add("https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.js");
      } catch {
        await add("https://unpkg.com/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.js");
      }

      // Quick diagnostics for library load
      const tfOK  = !!(window.tf);
      const pdOK  = !!(window.poseDetection);
      diag(`TFJS: ${tfOK ? '<b>ok</b>' : '<i>missing</i>'} • Pose-Detection: ${pdOK ? '<b>ok</b>' : '<i>missing</i>'}`);

      if (tfOK && pdOK) {
        setTimeout(startApp, 10);
      } else {
        console.error('Libraries not loaded:', { tfOK, pdOK });
      }
    }
    boot();
  })();
</script>

<!-- ====== App code ====== -->
<script>
/* ======================================================================
   Dino Jump with MoveNet — Head/Face Up/Down → Jump (dynamic high jump)
   - Uses AVAILABLE head/face keypoints: nose, left/right_eye, left/right_ear.
   - Averages the visible ones (score>0.5) into a single "head anchor".
   - Detects BOTH up and down motion (absolute delta).
   - Jump strength scales with motion magnitude (bigger move → higher jump),
     with safe clamping to a maximum.
   - No ESM imports; uses global `tf` and `poseDetection`.
   ====================================================================== */

const video = document.getElementById('webcam');
const overlay = document.getElementById('overlay');
const octx = overlay.getContext('2d');
const statusText = document.getElementById('status');
const errorMsg = document.getElementById('errorMsg');

let detector;

// --- Head/Face gesture tracking constants/vars ---
const HEAD_KP_NAMES = ['nose', 'left_eye', 'right_eye', 'left_ear', 'right_ear'];
const headHistory = [];
const HISTORY_LENGTH = 8;

// Sensitivity threshold ~ 6% of video height (tune 0.05–0.09)
const GESTURE_THRESHOLD_RATIO = 0.06;

let jumpCooldown = 0;
// Light smoothing to reduce jitter
let smoothY = null;
const SMOOTH_ALPHA = 0.25;

function setDiag(extra) {
  const tfOK  = !!(window.tf);
  const pdOK  = !!(window.poseDetection);
  document.getElementById('diag').innerHTML =
    `TFJS: ${tfOK ? '<b>ok</b>' : '<i>missing</i>'} • Pose-Detection: ${pdOK ? '<b>ok</b>' : '<i>missing</i>'}` +
    (extra ? ' • ' + extra : '');
}

// ---------- Hi‑DPI canvas scaling ----------
function fitCanvasToDPR(canvasEl) {
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rect = canvasEl.getBoundingClientRect();
  canvasEl.width  = Math.round(rect.width  * dpr);
  canvasEl.height = Math.round(rect.height * dpr);
  const ctx = canvasEl.getContext('2d');
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
function resizeOverlay() {
  overlay.style.width  = video.offsetWidth + "px";
  overlay.style.height = video.offsetHeight + "px";
  fitCanvasToDPR(overlay);
}

// ---------- Webcam + Detector ----------
async function initWebcamAndDetector() {
  try {
    // Prefer WebGL backend for speed, but fall back if needed
    try { await tf.setBackend('webgl'); } catch { await tf.setBackend('cpu'); }
    await tf.ready();

    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "user" },
      audio: false
    });
    video.srcObject = stream;

    await video.play(); // iOS needs autoplay+muted+playsinline
    statusText.textContent = "Camera ready. Move your head/face UP or DOWN to jump!";
    video.onloadedmetadata = () => resizeOverlay();

    setDiag('camera: <b>ok</b>');

    // Create MoveNet Lightning (fast single‑pose)
    detector = await poseDetection.createDetector(
      poseDetection.SupportedModels.MoveNet,
      {
        modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
        enableSmoothing: true
      }
    );

    detectPose();
  } catch (e) {
    errorMsg.textContent = "Error initializing webcam or detector:\n" + (e.stack || e.message || e);
    setDiag('<i>camera/detector error</i>');
  }
}

function drawHeadDot(x, y) {
  octx.save();
  octx.fillStyle = "rgba(255, 140, 0, 0.95)"; // DarkOrange for head/face anchor
  octx.beginPath();
  octx.arc(x, y, 4, 0, Math.PI * 2);
  octx.fill();
  octx.restore();
}

// Utility: average any available head/face keypoints above confidence
function computeHeadAnchor(keypoints, minScore = 0.5) {
  let sx = 0, sy = 0, n = 0;
  for (const name of HEAD_KP_NAMES) {
    const k = keypoints.find(p => p.name === name);
    if (k && k.score > minScore) {
      sx += k.x; sy += k.y; n++;
    }
  }
  if (n === 0) return null;
  return { x: sx / n, y: sy / n, count: n };
}

async function detectPose() {
  try {
    if (!detector || video.videoWidth === 0 || video.videoHeight === 0) {
      requestAnimationFrame(detectPose);
      return;
    }
    resizeOverlay();
    octx.clearRect(0, 0, overlay.width, overlay.height);

    const poses = await detector.estimatePoses(video);
    if (poses.length > 0) {
      const kp = poses[0].keypoints;

      const anchor = computeHeadAnchor(kp, 0.5);
      if (anchor) {
        // Smooth y to reduce jitter
        smoothY = (smoothY == null) ? anchor.y : (SMOOTH_ALPHA * anchor.y + (1 - SMOOTH_ALPHA) * smoothY);

        // Keep short history
        headHistory.push(smoothY);
        if (headHistory.length > HISTORY_LENGTH) headHistory.shift();

        // Visual debug marker
        drawHeadDot(anchor.x, anchor.y);

        // Detect BOTH up and down: check absolute motion vs threshold
        if (headHistory.length === HISTORY_LENGTH && jumpCooldown === 0) {
          const baselineAvg = headHistory
            .slice(0, HISTORY_LENGTH - 2)
            .reduce((a, b) => a + b, 0) / (HISTORY_LENGTH - 2);

          // deltaUp   = baseline - current (positive when moved UP)
          // deltaDown = current - baseline (positive when moved DOWN)
          const delta = Math.abs(baselineAvg - smoothY);
          const thresholdPx = (overlay.height || 120) * GESTURE_THRESHOLD_RATIO;

          if (delta > thresholdPx) {
            // Scale jump power with how much the head moved relative to threshold.
            const intensity = Math.min(3.0, Math.max(1.0, delta / thresholdPx));
            jumpWithStrength(intensity);
            jumpCooldown = 15; // debounce frames
          }
        }
      }
    }
  } catch (err) {
    errorMsg.textContent = "Pose detection error:\n" + (err.stack || err.message || err);
  }

  if (jumpCooldown > 0) jumpCooldown--;
  requestAnimationFrame(detectPose);
}

// ---------- Game ----------
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const GROUND_Y = 170;
const DINO_WIDTH = 44, DINO_HEIGHT = 47;
const CACTUS_WIDTH = 20, CACTUS_HEIGHT = 40;
const GRAVITY = 0.35;

// BASE jump speed (magnitude) — higher than before for “much higher”
// We'll still scale it dynamically by gesture intensity.
const BASE_JUMP_SPEED = 12;   // was ~6–8 before
const MAX_JUMP_SPEED  = 22;   // clamp to avoid absurd launches

const DINO_X = 50;

let dino = {}, cacti = [], cactusTimer = 0;
let score = 0, highScore = 0, gameOver = false;
let restartTimer = 0;

function initDino() {
  dino = { x: DINO_X, y: GROUND_Y - DINO_HEIGHT, vy: 0, jumping: false, alive: true, frame: 0, legSwap: false };
}

function drawDino() {
  ctx.save();
  ctx.translate(dino.x, dino.y);
  ctx.fillStyle = "#666";
  ctx.fillRect(0, 10, 34, 30);
  ctx.fillRect(28, 0, 16, 18);
  ctx.fillStyle = "#fff";
  ctx.fillRect(39, 6, 3, 3);
  ctx.fillStyle = "#222";
  ctx.fillRect(40, 7, 1, 1);
  ctx.fillStyle = "#444";
  ctx.fillRect(10, 30, 8, 6);
  ctx.fillRect(24, 30, 8, 6);
  ctx.fillStyle = "#333";
  if (dino.legSwap) {
    ctx.fillRect(8, 40, 8, 7);
    ctx.fillRect(24, 40, 8, 7);
  } else {
    ctx.fillRect(14, 40, 8, 7);
    ctx.fillRect(18, 40, 8, 7);
  }
  ctx.restore();
}

function drawCactus(c) {
  ctx.save();
  ctx.translate(c.x, c.y);
  ctx.fillStyle = "#228B22";
  ctx.fillRect(0, 0, CACTUS_WIDTH, CACTUS_HEIGHT);
  ctx.fillRect(-5, 10, 5, 15);
  ctx.fillRect(CACTUS_WIDTH, 20, 5, 10);
  ctx.restore();
}

function drawGround() {
  ctx.strokeStyle = "#888";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, GROUND_Y + 1);
  ctx.lineTo(canvas.width, GROUND_Y + 1);
  ctx.stroke();
}

function drawScore() {
  ctx.font = "20px monospace";
  ctx.fillStyle = "#444";
  ctx.fillText("Score: " + score, 10, 30);
  ctx.fillText("High: " + highScore, 10, 55);
}

function update() {
  if (!gameOver) {
    dino.frame++;
    if (dino.frame % 14 === 0) dino.legSwap = !dino.legSwap;

    if (dino.jumping) {
      dino.vy += GRAVITY;
      dino.y += dino.vy;
      if (dino.y >= GROUND_Y - DINO_HEIGHT) {
        dino.y = GROUND_Y - DINO_HEIGHT;
        dino.vy = 0;
        dino.jumping = false;
      }
    }

    cactusTimer--;
    if (cactusTimer <= 0) {
      cacti.push({ x: canvas.width, y: GROUND_Y - CACTUS_HEIGHT, width: CACTUS_WIDTH, height: CACTUS_HEIGHT });
      cactusTimer = 120 + Math.floor(Math.random() * 60);
    }

    for (let i = 0; i < cacti.length; i++) cacti[i].x -= 3;
    cacti = cacti.filter(c => c.x + c.width > 0);

    for (let c of cacti) {
      if (dino.x + DINO_WIDTH > c.x && dino.x < c.x + c.width && dino.y + DINO_HEIGHT > c.y && dino.y < c.y + c.height) {
        gameOver = true;
        dino.alive = false;
        if (score > highScore) highScore = score;
        restartTimer = 60;
      }
    }
    score++;
  } else {
    restartTimer--;
    if (restartTimer <= 0) restart();
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawGround();
  drawDino();
  for (let c of cacti) drawCactus(c);
  drawScore();
  if (gameOver) {
    ctx.font = "32px monospace";
    ctx.fillStyle = "#c00";
    ctx.fillText("GAME OVER", canvas.width/2-100, 100);
  }
}

let paused = false;
function loop() {
  if (!paused) { update(); draw(); }
  requestAnimationFrame(loop);
}

// Jump with dynamic strength (≥1.0). Larger = higher jump.
function jumpWithStrength(strength) {
  // Only start a new jump if not already mid-air
  if (!gameOver && !dino.jumping) {
    const speed = Math.min(MAX_JUMP_SPEED, BASE_JUMP_SPEED * strength);
    dino.vy = -speed;     // negative vy = upwards
    dino.jumping = true;
  }
}

// Backward compatible single-tap jump
function jump() {
  jumpWithStrength(1.0);
}

function restart() {
  initDino();
  cacti = [];
  cactusTimer = 0;
  score = 0;
  gameOver = false;
}

function startApp() {
  initWebcamAndDetector();
  restart();
  loop();

  // Fallback controls
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space' || e.code === 'ArrowUp') jump();
  });
  overlay.addEventListener('click', jump);

  // Pause when tab hidden
  document.addEventListener('visibilitychange', () => {
    paused = document.hidden;
  });

  // Cleanup
  window.addEventListener('beforeunload', async () => {
    try { if (detector) await detector.dispose(); } catch {}
    const tracks = video.srcObject && video.srcObject.getTracks ? video.srcObject.getTracks() : [];
    tracks.forEach(t => t.stop());
  });

  // Handle resizes
  window.addEventListener('resize', () => resizeOverlay());
}

// Expose for the loader above
window.startApp = startApp;
</script>

</body>
</html>
