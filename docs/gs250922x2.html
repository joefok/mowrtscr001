
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Dino Jump with Pose Detection Fix</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body {
      margin: 0; padding: 0; background: #f7f7f7;
      font-family: sans-serif; overflow-x: hidden;
    }
    canvas#game {
      display: block; margin: 20px auto;
      background: #fff; border: 2px solid #888;
      max-width: 100%; height: auto;
    }
    #info {
      text-align: center; margin: 10px; font-size: 1em;
    }
    #corner {
      position: fixed; top: 10px; right: 10px;
      width: 30vw; min-width: 120px; max-width: 200px;
      border: 2px solid #444; background: #000; z-index: 10;
      border-radius: 8px; box-shadow: 0 2px 8px #0002;
      display: flex; flex-direction: column; align-items: center;
    }
    #gestureBar {
      width: 100%; height: 10px; background: gray;
      border-radius: 0 0 6px 6px;
    }
    #gestureMsg {
      color: lime; font-size: 0.8em; text-align: center;
      background: #000; padding: 2px;
    }
    #errorMsg {
      color: red; font-size: 0.9em; text-align: left;
      margin: 10px auto; max-width: 90vw; white-space: pre-wrap;
      background: #fee; padding: 10px; border: 1px solid #c00;
      font-family: monospace;
    }
    #videoWrap {
      position: relative; width: 100%; height: auto;
      aspect-ratio: 4/3;
    }
    video, canvas#overlay {
      position: absolute; left: 0; top: 0;
      width: 100%; height: 100%; border-radius: 8px 8px 0 0;
      display: block;
    }
    video { z-index: 1; }
    canvas#overlay { z-index: 2; pointer-events: none; }
    @media (max-width: 600px) {
      #corner { width: 40vw; min-width: 80px; }
      canvas#game { width: 98vw !important; height: auto !important; }
    }
  </style>
</head>
<body>
<canvas id="game" width="600" height="200"></canvas>
<div id="info">
  <span id="status">Jump by moving your head up or down! (Allow camera access)</span>
  <div id="errorMsg"></div>
</div>
<div id="corner">
  <div id="videoWrap">
    <video id="webcam" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>
  <div id="gestureMsg"></div>
  <div id="gestureBar"></div>
</div>
https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0</script>
https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@4.4.0/dist/pose-detection.min.js</script>
<script>
window.addEventListener('DOMContentLoaded', function() {
  const video = document.getElementById('webcam');
  const overlay = document.getElementById('overlay');
  const octx = overlay.getContext('2d');
  const gestureBar = document.getElementById('gestureBar');
  const gestureMsg = document.getElementById('gestureMsg');
  const statusText = document.getElementById('status');
  const errorMsg = document.getElementById('errorMsg');

  const noseHistory = [];
  const HISTORY_LENGTH = 8;
  const GESTURE_THRESHOLD = 22;
  let jumpCooldown = 0;
  let detector;

  function resizeOverlay() {
    overlay.width = video.videoWidth || 160;
    overlay.height = video.videoHeight || 120;
    overlay.style.width = video.offsetWidth + "px";
    overlay.style.height = video.offsetHeight + "px";
  }
  window.addEventListener('resize', resizeOverlay);

  async function initWebcamAndDetector() {
    try {
      if (!window.poseDetection) throw new Error("poseDetection is not defined. Pose Detection library failed to load.");
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" } });
      video.srcObject = stream;
      await video.play();
      statusText.textContent = "Camera active. Move head up/down to jump!";
      video.onloadedmetadata = () => {
        resizeOverlay();
        overlay.width = video.videoWidth;
        overlay.height = video.videoHeight;
      };
      detector = await window.poseDetection.createDetector(window.poseDetection.SupportedModels.MoveNet);
      detectPose();
    } catch (e) {
      errorMsg.textContent = "Error initializing webcam or detector:\n" + (e.stack || e.message || e);
    }
  }

  async function detectPose() {
    try {
      if (!detector || video.videoWidth === 0 || video.videoHeight === 0) {
        requestAnimationFrame(detectPose);
        return;
      }
      resizeOverlay();
      const poses = await detector.estimatePoses(video);
      octx.clearRect(0, 0, overlay.width, overlay.height);
      if (poses.length > 0) {
        const keypoints = poses[0].keypoints;
        let minX=9999, minY=9999, maxX=0, maxY=0;
        keypoints.forEach(k => {
          if (k.score > 0.5) {
            const x = k.x * overlay.width / video.videoWidth;
            const y = k.y * overlay.height / video.videoHeight;
            octx.fillStyle = "red";
            octx.beginPath();
            octx.arc(x, y, 3, 0, 2 * Math.PI);
            octx.fill();
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
          }
        });
        if (minX < maxX && minY < maxY) {
          octx.strokeStyle = "lime";
          octx.lineWidth = 2;
          octx.strokeRect(minX-4, minY-4, (maxX-minX)+8, (maxY-minY)+8);
        }
        const nose = keypoints.find(k => k.name === 'nose');
        if (nose && nose.score > 0.5) {
          noseHistory.push(nose.y);
          if (noseHistory.length > HISTORY_LENGTH) noseHistory.shift();
          if (noseHistory.length === HISTORY_LENGTH && jumpCooldown === 0) {
            const avgPrev = noseHistory.slice(0, HISTORY_LENGTH - 2).reduce((a, b) => a + b, 0) / (HISTORY_LENGTH - 2);
            const delta = nose.y - avgPrev;
            if (Math.abs(delta) > GESTURE_THRESHOLD) {
              gestureBar.style.background = "lime";
              gestureMsg.textContent = "Gesture Detected!";
              jumpCooldown = 15;
              if (typeof jump === "function") jump();
            } else {
              gestureBar.style.background = "gray";
              gestureMsg.textContent = "";
            }
          }
        }
      }
    } catch (err) {
      errorMsg.textContent = "Pose detection error:\n" + (err.stack || err.message || err);
    }
    if (jumpCooldown > 0) jumpCooldown--;
    requestAnimationFrame(detectPose);
  }

  // Game logic
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const GROUND_Y = 170;
  const DINO_WIDTH = 44, DINO_HEIGHT = 47;
  const CACTUS_WIDTH = 20, CACTUS_HEIGHT = 40;
  const GRAVITY = 0.35;
  const JUMP_VELOCITY = -6;
  const DINO_X = 50;
  let dino = {}, cacti = [], cactusTimer = 0;
  let score = 0, highScore = 0, gameOver = false;
  let restartTimer = 0;

  function initDino() {
    dino = {
      x: DINO_X,
      y: GROUND_Y - DINO_HEIGHT,
      vy: 0,
      jumping: false,
      alive: true,
      frame: 0,
      legSwap: false
    };
  }

  function drawDino() {
    ctx.save();
    ctx.translate(dino.x, dino.y);
    ctx.fillStyle = "#666";
    ctx.fillRect(0, 10, 34, 30);
    ctx.fillRect(28, 0, 16, 18);
    ctx.fillStyle = "#fff";
    ctx.fillRect(39, 6, 3, 3);
    ctx.fillStyle = "#222";
    ctx.fillRect(40, 7, 1, 1);
    ctx.fillStyle = "#444";
    ctx.fillRect(10, 30, 8, 6);
    ctx.fillRect(24, 30, 8, 6);
    ctx.fillStyle = "#333";
    if (dino.legSwap) {
      ctx.fillRect(8, 40, 8, 7);
      ctx.fillRect(24, 40, 8, 7);
    } else {
      ctx.fillRect(14, 40, 8, 7);
      ctx.fillRect(18, 40, 8, 7);
    }
    ctx.restore();
  }

  function drawCactus(c) {
    ctx.save();
    ctx.translate(c.x, c.y);
    ctx.fillStyle = "#228B22";
    ctx.fillRect(0, 0, CACTUS_WIDTH, CACTUS_HEIGHT);
    ctx.fillRect(-5, 10, 5, 15);
    ctx.fillRect(CACTUS_WIDTH, 20, 5, 10);
    ctx.restore();
  }

  function drawGround() {
    ctx.strokeStyle = "#888";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, GROUND_Y + 1);
    ctx.lineTo(canvas.width, GROUND_Y + 1);
    ctx.stroke();
  }

  function drawScore() {
    ctx.font = "20px monospace";
    ctx.fillStyle = "#444";
    ctx.fillText("Score: " + score, 10, 30);
    ctx.fillText("High: " + highScore, 10, 55);
  }

  function update() {
    if (!gameOver) {
      dino.frame++;
      if (dino.frame % 14 === 0) dino.legSwap = !dino.legSwap;
      if (dino.jumping) {
        dino.vy += GRAVITY;
        dino.y += dino.vy;
        if (dino.y >= GROUND_Y - DINO_HEIGHT) {
          dino.y = GROUND_Y - DINO_HEIGHT;
          dino.vy = 0;
          dino.jumping = false;
        }
      }
      cactusTimer--;
      if (cactusTimer <= 0) {
        cacti.push({
          x: canvas.width,
          y: GROUND_Y - CACTUS_HEIGHT,
          width: CACTUS_WIDTH,
          height: CACTUS_HEIGHT
        });
        cactusTimer = 120 + Math.floor(Math.random() * 60);
      }
      for (let i = 0; i < cacti.length; i++) {
        cacti[i].x -= 3;
      }
      cacti = cacti.filter(c => c.x + c.width > 0);
      for (let c of cacti) {
        if (
          dino.x + DINO_WIDTH > c.x &&
          dino.x < c.x + c.width &&
          dino.y + DINO_HEIGHT > c.y &&
          dino.y < c.y + c.height
        ) {
          gameOver = true;
          dino.alive = false;
          if (score > highScore) highScore = score;
          restartTimer = 60;
        }
      }
      score++;
    } else {
      restartTimer--;
      if (restartTimer <= 0) {
        restart();
      }
    }
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawGround();
    drawDino();
    for (let c of cacti) drawCactus(c);
    drawScore();
    if (gameOver) {
      ctx.font = "32px sans-serif";
      ctx.fillStyle = "#c00";
      ctx.fillText("GAME OVER", canvas.width/2-100, 100);
    }
  }

  function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
  }

  function jump() {
    if (!gameOver && !dino.jumping) {
      dino.vy = JUMP_VELOCITY;
      dino.jumping = true;
    }
  }

  function restart() {
    initDino();
    cacti = [];
    cactusTimer = 0;
    score = 0;
    gameOver = false;
  }

  initWebcamAndDetector();
  restart();
  loop();
});
</script>
</body>
</html>