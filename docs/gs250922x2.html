<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dino Jump — Full-Viewport Responsive + Slower Enemies</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
    html, body { height:100%; margin:0; overflow:hidden; background:#f7f7f7; color:#222; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    /* Game canvas fills the viewport; JS sets the height to window.innerHeight for iOS */
    #game { display:block; width:100vw; height:100vh; background:#fff; }
    #info  { position:fixed; left:10px; bottom:10px; right:10px; text-align:center; font-size:14px; }
    #status { display:inline-block; margin-bottom:4px; background:#fff; padding:4px 8px; border-radius:6px; box-shadow:0 1px 4px rgba(0,0,0,0.1); }
    #errorMsg { color:#c00; white-space:pre-wrap; max-width:800px; margin:6px auto; }

    /* Webcam preview + overlay (kept compact, pinned top-right) */
    #webcam { position:fixed; top:10px; right:10px; width:160px; border:2px solid #444; border-radius:4px; }
    #overlay { position:fixed; top:10px; right:10px; width:160px; pointer-events:auto; }
    #overlayTapHint { position:fixed; top:172px; right:10px; width:160px; text-align:center; color:#222; font-size:12px; pointer-events:none; }

    /* Diagnostics banner */
    #diag { position:fixed; left:10px; top:10px; background:#fff; border:1px solid #ccc; padding:6px 8px; font:12px monospace; border-radius:4px; z-index:9999; }
    #diag b { color:#0a0; }
    #diag i { color:#a00; }
  </style>
</head>
<body>

<div id="diag">Loading…</div>

<canvas id="game"></canvas>

<div id="info">
  <span id="status">
    Allow camera, then move your <strong>head/face up or down</strong> to jump (bigger move → higher jump).
  </span>
  <div id="errorMsg"></div>
</div>

<!-- Webcam preview + overlay -->
<video id="webcam" autoplay playsinline muted></video>
<canvas id="overlay"></canvas>
<div id="overlayTapHint">Tip: tap the preview or press Space/↑ to jump</div>

<!-- ====== Load TFJS & Pose Detection with automatic fallback ====== -->
<script>
  (function loadLibs(){
    const head = document.head;
    function add(src) {
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = src;
        s.onload = () => resolve(src);
        s.onerror = () => reject(new Error('Failed: ' + src));
        head.appendChild(s);
      });
    }
    async function boot() {
      const diag = (msg) => document.getElementById('diag').innerHTML = msg;
      try { await add("https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"); }
      catch { await add("https://unpkg.com/@tensorflow/tfjs@4.18.0/dist/tf.min.js"); }
      try { await add("https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.js"); }
      catch { await add("https://unpkg.com/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.js"); }

      const tfOK  = !!(window.tf);
      const pdOK  = !!(window.poseDetection);
      diag(`TFJS: ${tfOK ? '<b>ok</b>' : '<i>missing</i>'} • Pose-Detection: ${pdOK ? '<b>ok</b>' : '<i>missing</i>'}`);
      if (tfOK && pdOK) setTimeout(startApp, 10);
    }
    boot();
  })();
</script>

<!-- ====== App code ====== -->
<script>
/* ======================================================================
   Dino Jump — Full-Viewport Responsive + Slower Enemies
   - Full viewport canvas with Hi-DPI crispness and non-uniform scaling
     to utilize all available space.
   - Enemy speed reduced.
   - Head/face (nose/eyes/ears) up or down => jump; magnitude => jump power.
   ====================================================================== */

const video = document.getElementById('webcam');
const overlay = document.getElementById('overlay');
const octx = overlay.getContext('2d');
const statusText = document.getElementById('status');
const errorMsg = document.getElementById('errorMsg');
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// ---------- Responsive canvas (logical coordinates → full viewport) ----------
const LOGICAL_W = 600, LOGICAL_H = 200;  // original world units
let scaleX = 1, scaleY = 1;

function fitCanvasToDPR(c) {
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rect = c.getBoundingClientRect();
  c.width  = Math.round(rect.width  * dpr);
  c.height = Math.round(rect.height * dpr);
  const g = c.getContext('2d');
  g.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function sizeGameCanvas() {
  // Fill visible viewport height (handles mobile URL bar)
  canvas.style.width = '100vw';
  canvas.style.height = window.innerHeight + 'px';
  fitCanvasToDPR(canvas);
  const rect = canvas.getBoundingClientRect();
  scaleX = rect.width  / LOGICAL_W;
  scaleY = rect.height / LOGICAL_H;
}
window.addEventListener('resize', sizeGameCanvas);
window.addEventListener('orientationchange', () => setTimeout(sizeGameCanvas, 100));
sizeGameCanvas();

// ---------- Overlay sizing ----------
function resizeOverlay() {
  overlay.style.width  = video.offsetWidth + "px";
  overlay.style.height = video.offsetHeight + "px";
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rect = overlay.getBoundingClientRect();
  overlay.width  = Math.round(rect.width  * dpr);
  overlay.height = Math.round(rect.height * dpr);
  octx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

// ---------- Gesture detection (MoveNet) ----------
let detector;
const HEAD_KP_NAMES = ['nose', 'left_eye', 'right_eye', 'left_ear', 'right_ear'];
const headHistory = [];
const HISTORY_LENGTH = 8;
const GESTURE_THRESHOLD_RATIO = 0.06;  // sensitivity (ratio of overlay height)
let jumpCooldown = 0;
let smoothY = null;
const SMOOTH_ALPHA = 0.25;

function setDiag(extra) {
  const tfOK  = !!(window.tf);
  const pdOK  = !!(window.poseDetection);
  document.getElementById('diag').innerHTML =
    `TFJS: ${tfOK ? '<b>ok</b>' : '<i>missing</i>'} • Pose-Detection: ${pdOK ? '<b>ok</b>' : '<i>missing</i>'}` +
    (extra ? ' • ' + extra : '');
}

async function initWebcamAndDetector() {
  try {
    try { await tf.setBackend('webgl'); } catch { await tf.setBackend('cpu'); }
    await tf.ready();

    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" }, audio: false });
    video.srcObject = stream;
    await video.play();
    statusText.textContent = "Camera ready. Move head/face UP or DOWN to jump!";
    video.onloadedmetadata = () => resizeOverlay();
    setDiag('camera: <b>ok</b>');

    detector = await poseDetection.createDetector(
      poseDetection.SupportedModels.MoveNet,
      { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING, enableSmoothing: true }
    );
    detectPose();
  } catch (e) {
    errorMsg.textContent = "Error initializing webcam or detector:\n" + (e.stack || e.message || e);
    setDiag('<i>camera/detector error</i>');
  }
}

function drawHeadDot(x, y) {
  octx.save(); octx.fillStyle = "rgba(255, 140, 0, 0.95)";
  octx.beginPath(); octx.arc(x, y, 4, 0, Math.PI*2); octx.fill(); octx.restore();
}

function computeHeadAnchor(keypoints, minScore = 0.5) {
  let sx=0, sy=0, n=0;
  for (const name of HEAD_KP_NAMES) {
    const k = keypoints.find(p => p.name === name);
    if (k && k.score > minScore) { sx += k.x; sy += k.y; n++; }
  }
  if (!n) return null;
  return { x: sx/n, y: sy/n, count:n };
}

async function detectPose() {
  try {
    if (!detector || video.videoWidth === 0 || video.videoHeight === 0) {
      requestAnimationFrame(detectPose); return;
    }
    resizeOverlay(); octx.clearRect(0,0,overlay.width,overlay.height);

    const poses = await detector.estimatePoses(video);
    if (poses.length > 0) {
      const kp = poses[0].keypoints;
      const anchor = computeHeadAnchor(kp, 0.5);
      if (anchor) {
        smoothY = (smoothY == null) ? anchor.y : (SMOOTH_ALPHA*anchor.y + (1-SMOOTH_ALPHA)*smoothY);
        headHistory.push(smoothY);
        if (headHistory.length > HISTORY_LENGTH) headHistory.shift();
        drawHeadDot(anchor.x, anchor.y);

        if (headHistory.length === HISTORY_LENGTH && jumpCooldown === 0) {
          const baseline = headHistory.slice(0, HISTORY_LENGTH-2).reduce((a,b)=>a+b,0) / (HISTORY_LENGTH-2);
          const delta = Math.abs(baseline - smoothY);   // up OR down
          const thresholdPx = (overlay.height || 120) * GESTURE_THRESHOLD_RATIO;
          if (delta > thresholdPx) {
            const intensity = Math.min(3.0, Math.max(1.0, delta / thresholdPx));
            jumpWithStrength(intensity);
            jumpCooldown = 15;
          }
        }
      }
    }
  } catch (err) {
    errorMsg.textContent = "Pose detection error:\n" + (err.stack || err.message || err);
  }
  if (jumpCooldown > 0) jumpCooldown--;
  requestAnimationFrame(detectPose);
}

// ---------- Game (logical 600×200; scaled to viewport) ----------
const GROUND_Y = 170;
const DINO_WIDTH = 44, DINO_HEIGHT = 47;
const CACTUS_WIDTH = 20, CACTUS_HEIGHT = 40;
const GRAVITY = 0.35;

// Slower enemies
const ENEMY_SPEED = 2;  // was 3

// Higher, dynamic jump (scaled by gesture intensity)
const BASE_JUMP_SPEED = 12;
const MAX_JUMP_SPEED  = 22;

const DINO_X = 50;

let dino = {}, cacti = [], cactusTimer = 0;
let score = 0, highScore = 0, gameOver = false;
let restartTimer = 0;

function initDino() {
  dino = { x: DINO_X, y: GROUND_Y - DINO_HEIGHT, vy: 0, jumping: false, alive: true, frame: 0, legSwap: false };
}

function drawDino() {
  ctx.save();
  ctx.translate(dino.x, dino.y);
  ctx.fillStyle = "#666";
  ctx.fillRect(0, 10, 34, 30);
  ctx.fillRect(28, 0, 16, 18);
  ctx.fillStyle = "#fff"; ctx.fillRect(39, 6, 3, 3);
  ctx.fillStyle = "#222"; ctx.fillRect(40, 7, 1, 1);
  ctx.fillStyle = "#444"; ctx.fillRect(10, 30, 8, 6); ctx.fillRect(24, 30, 8, 6);
  ctx.fillStyle = "#333";
  if (dino.legSwap) { ctx.fillRect(8, 40, 8, 7); ctx.fillRect(24, 40, 8, 7); }
  else              { ctx.fillRect(14, 40, 8, 7); ctx.fillRect(18, 40, 8, 7); }
  ctx.restore();
}

function drawCactus(c) {
  ctx.save();
  ctx.translate(c.x, c.y);
  ctx.fillStyle = "#228B22";
  ctx.fillRect(0, 0, CACTUS_WIDTH, CACTUS_HEIGHT);
  ctx.fillRect(-5, 10, 5, 15);
  ctx.fillRect(CACTUS_WIDTH, 20, 5, 10);
  ctx.restore();
}

function drawGround() {
  ctx.strokeStyle = "#888"; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(0, GROUND_Y + 1); ctx.lineTo(LOGICAL_W, GROUND_Y + 1); ctx.stroke();
}

function drawScore() {
  ctx.font = "20px monospace";
  ctx.fillStyle = "#444";
  ctx.fillText("Score: " + score, 10, 30);
  ctx.fillText("High: " + highScore, 10, 55);
}

function update() {
  if (!gameOver) {
    dino.frame++; if (dino.frame % 14 === 0) dino.legSwap = !dino.legSwap;

    if (dino.jumping) {
      dino.vy += GRAVITY;
      dino.y += dino.vy;
      if (dino.y >= GROUND_Y - DINO_HEIGHT) {
        dino.y = GROUND_Y - DINO_HEIGHT;
        dino.vy = 0; dino.jumping = false;
      }
    }

    cactusTimer--;
    if (cactusTimer <= 0) {
      cacti.push({ x: LOGICAL_W, y: GROUND_Y - CACTUS_HEIGHT, width: CACTUS_WIDTH, height: CACTUS_HEIGHT });
      cactusTimer = 120 + Math.floor(Math.random() * 60);
    }

    for (let i = 0; i < cacti.length; i++) cacti[i].x -= ENEMY_SPEED;
    cacti = cacti.filter(c => c.x + c.width > 0);

    for (let c of cacti) {
      if (DINO_X + DINO_WIDTH > c.x && DINO_X < c.x + c.width && dino.y + DINO_HEIGHT > c.y && dino.y < c.y + c.height) {
        gameOver = true; dino.alive = false;
        if (score > highScore) highScore = score;
        restartTimer = 60;
      }
    }
    score++;
  } else {
    restartTimer--; if (restartTimer <= 0) restart();
  }
}

function draw() {
  // Clear full viewport canvas (device pixels handled by fitCanvasToDPR)
  ctx.save();
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Scale logical 600×200 to current viewport (non-uniform to utilize all space)
  ctx.scale(scaleX, scaleY);

  drawGround();
  // Draw dino at its logical position
  ctx.save(); drawDino(); ctx.restore();

  // Draw cacti
  for (let c of cacti) drawCactus(c);

  // Score text (in logical units so it scales)
  drawScore();

  if (gameOver) {
    ctx.font = "32px monospace";
    ctx.fillStyle = "#c00";
    ctx.fillText("GAME OVER", LOGICAL_W/2 - 100, 100);
  }

  ctx.restore();
}

let paused = false;
function loop() {
  if (!paused) { update(); draw(); }
  requestAnimationFrame(loop);
}

// Jump with dynamic strength (≥1.0). Larger = higher jump.
function jumpWithStrength(strength) {
  if (!gameOver && !dino.jumping) {
    const speed = Math.min(MAX_JUMP_SPEED, BASE_JUMP_SPEED * strength);
    dino.vy = -speed; dino.jumping = true;
  }
}
// Backward compatible single-tap jump
function jump() { jumpWithStrength(1.0); }

function restart() {
  initDino(); cacti = []; cactusTimer = 0; score = 0; gameOver = false;
}

// ---------- App bootstrap ----------
function startApp() {
  initWebcamAndDetector();
  restart();
  loop();

  // Fallback controls
  window.addEventListener('keydown', (e) => { if (e.code === 'Space' || e.code === 'ArrowUp') jump(); });
  overlay.addEventListener('click', jump);

  // Pause when tab hidden
  document.addEventListener('visibilitychange', () => { paused = document.hidden; });

  // Cleanup
  window.addEventListener('beforeunload', async () => {
    try { if (detector) await detector.dispose(); } catch {}
    const tracks = video.srcObject?.getTracks?.() || [];
    tracks.forEach(t => t.stop());
  });
}
</script>

</body>
</html>
