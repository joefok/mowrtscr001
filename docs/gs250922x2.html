<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dino Jump — Any Jump to Border (+ Optional Double Higher)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
    html, body { height:100%; margin:0; overflow:hidden; background:#f7f7f7; color:#222; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    /* Game canvas fills the viewport; JS sets height to window.innerHeight for iOS */
    #game { display:block; width:100vw; height:100vh; background:#fff; }

    /* Info text: non-blocking and auto-fade */
    #info  { position:fixed; left:0; right:0; bottom:0; text-align:center; pointer-events:none; }
    #status {
      display:inline-block; margin:8px auto;
      background: rgba(255,255,255,0.78); padding:6px 10px; border-radius:8px;
      box-shadow:0 1px 6px rgba(0,0,0,0.10);
      font-size:14px; line-height:1.2; max-width:92vw;
      transition: opacity 600ms ease;
    }
    #status.hidden { opacity:0; }

    #errorMsg { color:#c00; white-space:pre-wrap; max-width:800px; margin:6px auto; }

    /* Webcam preview + overlay (compact, pinned top-right) */
    #webcam { position:fixed; top:10px; right:10px; width:160px; border:2px solid #444; border-radius:4px; }
    #overlay { position:fixed; top:10px; right:10px; width:160px; pointer-events:auto; }
    #overlayTapHint { position:fixed; top:172px; right:10px; width:160px; text-align:center; color:#222; font-size:12px; pointer-events:none; }

    /* Diagnostics banner */
    #diag { position:fixed; left:10px; top:10px; background:#fff; border:1px solid #ccc; padding:6px 8px; font:12px monospace; border-radius:4px; z-index:9999; }
    #diag b { color:#0a0; }
    #diag i { color:#a00; }
  </style>
</head>
<body>

<div id="diag">Loading…</div>

<canvas id="game"></canvas>

<div id="info">
  <span id="status">
    Move your <strong>head/face up or down</strong> — <em>any jump</em> goes to the top border (optionally “double higher” feel).
  </span>
  <div id="errorMsg"></div>
</div>

<!-- Webcam preview + overlay -->
<video id="webcam" autoplay playsinline muted></video>
<canvas id="overlay"></canvas>
<div id="overlayTapHint">Tap webcam or press Space/↑ to jump</div>

<!-- ====== Load TFJS & Pose Detection with automatic fallback ====== -->
<script>
  (function loadLibs(){
    const head = document.head;
    function add(src) {
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = src;
        s.onload = () => resolve(src);
        s.onerror = () => reject(new Error('Failed: ' + src));
        head.appendChild(s);
      });
    }
    async function boot() {
      const diag = (msg) => document.getElementById('diag').innerHTML = msg;
      try { await add("https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"); }
      catch { await add("https://unpkg.com/@tensorflow/tfjs@4.18.0/dist/tf.min.js"); }
      try { await add("https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.js"); }
      catch { await add("https://unpkg.com/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.js"); }

      const tfOK  = !!(window.tf);
      const pdOK  = !!(window.poseDetection);
      diag(`TFJS: ${tfOK ? '<b>ok</b>' : '<i>missing</i>'} • Pose-Detection: ${pdOK ? '<b>ok</b>' : '<i>missing</i>'}`);
      if (tfOK && pdOK) setTimeout(startApp, 10);
    }
    boot();
  })();
</script>

<!-- ====== App code ====== -->
<script>
/* ======================================================================
   Dino Jump — Any Jump to Border (+ Optional Double Higher)
   - Uniform scaling: no stretched sprites (portrait & landscape).
   - Max jump height: every jump hits top of logical game area (ceiling clamp).
   - Optional "double higher" feel: boosted launch speed but still clamped to top.
   - Slower fall: separate ascent/descent gravity (floatier descent).
   - Gesture: head/face (nose/eyes/ears) up/down triggers jump.
   ====================================================================== */

const video = document.getElementById('webcam');
const overlay = document.getElementById('overlay');
const octx = overlay.getContext('2d');
const statusText = document.getElementById('status');
const errorMsg = document.getElementById('errorMsg');
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

/* ---------------- Responsive canvas with Hi‑DPI + uniform scale ---------------- */
const LOGICAL_W = 600, LOGICAL_H = 200;  // original game units (keep proportions)
let uniScale = 1, offX = 0, offY = 0;

function fitCanvasToDPR(c) {
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rect = c.getBoundingClientRect();
  c.width  = Math.round(rect.width  * dpr);
  c.height = Math.round(rect.height * dpr);
  const g = c.getContext('2d');
  g.setTransform(dpr, 0, 0, dpr, 0, 0); // make 1 CSS px = 1 drawing unit
}

function sizeGameCanvas() {
  // Fill visible viewport height (handles mobile URL bar)
  canvas.style.width = '100vw';
  canvas.style.height = window.innerHeight + 'px';
  fitCanvasToDPR(canvas);
  const rect = canvas.getBoundingClientRect();

  // Uniform scale (no distortion): letterbox/pillarbox as needed
  const s = Math.min(rect.width / LOGICAL_W, rect.height / LOGICAL_H);
  uniScale = s;
  offX = (rect.width  - s * LOGICAL_W) / 2;
  offY = (rect.height - s * LOGICAL_H) / 2;
}
window.addEventListener('resize', sizeGameCanvas);
window.addEventListener('orientationchange', () => setTimeout(sizeGameCanvas, 100));
sizeGameCanvas();

/* ---------------- Overlay sizing ---------------- */
function resizeOverlay() {
  overlay.style.width  = video.offsetWidth + "px";
  overlay.style.height = video.offsetHeight + "px";
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rect = overlay.getBoundingClientRect();
  overlay.width  = Math.round(rect.width  * dpr);
  overlay.height = Math.round(rect.height * dpr);
  octx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

/* ---------------- Gesture detection (MoveNet) ---------------- */
let detector;
const HEAD_KP_NAMES = ['nose', 'left_eye', 'right_eye', 'left_ear', 'right_ear'];
const headHistory = [];
const HISTORY_LENGTH = 8;
// We no longer scale jump by gesture size, but keep threshold so micro-noise doesn't fire:
const GESTURE_THRESHOLD_RATIO = 0.05;

let jumpCooldown = 0;
let smoothY = null;
const SMOOTH_ALPHA = 0.25;

function setDiag(extra) {
  const tfOK  = !!(window.tf);
  const pdOK  = !!(window.poseDetection);
  document.getElementById('diag').innerHTML =
    `TFJS: ${tfOK ? '<b>ok</b>' : '<i>missing</i>'} • Pose-Detection: ${pdOK ? '<b>ok</b>' : '<i>missing</i>'}` +
    (extra ? ' • ' + extra : '');
}

async function initWebcamAndDetector() {
  try {
    try { await tf.setBackend('webgl'); } catch { await tf.setBackend('cpu'); }
    await tf.ready();

    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" }, audio: false });
    video.srcObject = stream;
    await video.play();
    statusText.textContent = "Camera ready. Any jump goes to the top border!";
    setTimeout(() => statusText.classList.add('hidden'), 3500); // auto-fade
    video.onloadedmetadata = () => resizeOverlay();
    setDiag('camera: <b>ok</b>');

    detector = await poseDetection.createDetector(
      poseDetection.SupportedModels.MoveNet,
      { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING, enableSmoothing: true }
    );
    detectPose();
  } catch (e) {
    errorMsg.textContent = "Error initializing webcam or detector:\n" + (e.stack || e.message || e);
    setDiag('<i>camera/detector error</i>');
  }
}

function drawHeadDot(x, y) {
  octx.save(); octx.fillStyle = "rgba(255, 140, 0, 0.95)";
  octx.beginPath(); octx.arc(x, y, 4, 0, Math.PI*2); octx.fill(); octx.restore();
}

function computeHeadAnchor(keypoints, minScore = 0.5) {
  let sx=0, sy=0, n=0;
  for (const name of HEAD_KP_NAMES) {
    const k = keypoints.find(p => p.name === name);
    if (k && k.score > minScore) { sx += k.x; sy += k.y; n++; }
  }
  if (!n) return null;
  return { x: sx/n, y: sy/n, count:n };
}

async function detectPose() {
  try {
    if (!detector || video.videoWidth === 0 || video.videoHeight === 0) {
      requestAnimationFrame(detectPose); return;
    }
    resizeOverlay(); octx.clearRect(0,0,overlay.width,overlay.height);

    const poses = await detector.estimatePoses(video);
    if (poses.length > 0) {
      const kp = poses[0].keypoints;
      const anchor = computeHeadAnchor(kp, 0.5);
      if (anchor) {
        smoothY = (smoothY == null) ? anchor.y : (SMOOTH_ALPHA*anchor.y + (1-SMOOTH_ALPHA)*smoothY);
        headHistory.push(smoothY);
        if (headHistory.length > HISTORY_LENGTH) headHistory.shift();
        drawHeadDot(anchor.x, anchor.y);

        if (headHistory.length === HISTORY_LENGTH && jumpCooldown === 0) {
          const baseline = headHistory.slice(0, HISTORY_LENGTH-2).reduce((a,b)=>a+b,0) / (HISTORY_LENGTH-2);
          const delta = Math.abs(baseline - smoothY);
          const thresholdPx = (overlay.height || 120) * GESTURE_THRESHOLD_RATIO;
          if (delta > thresholdPx) {
            // Any detected gesture triggers a "border jump"
            jumpToBorder();
            jumpCooldown = 5;
          }
        }
      }
    }
  } catch (err) {
    errorMsg.textContent = "Pose detection error:\n" + (err.stack || err.message || err);
  }
  if (jumpCooldown > 0) jumpCooldown--;
  requestAnimationFrame(detectPose);
}

/* ---------------- Game (logical 600×200; uniform scale) ---------------- */
const GROUND_Y = 170;
const DINO_WIDTH = 44, DINO_HEIGHT = 47;
const CACTUS_WIDTH = 20, CACTUS_HEIGHT = 40;

/* Slower fall + crisp launch: separate gravity */
const GRAVITY_ASC  = 0.45;  // going up
const GRAVITY_DESC = 0.18;  // falling down

/* Enemies slower (tune to taste) */
const ENEMY_SPEED = 2;

/* ====== Jump behavior controls ====== */
const FORCE_JUMP_TO_TOP   = true; // Any jump uses top-reaching speed
const DOUBLE_HIGHER_MODE  = true; // Optional: boost launch speed (still clamped to top)

/* Compute top-reaching launch speed using ascent gravity */
const TOP_MARGIN = 2; // tiny margin to avoid drawing beyond top
function computeMaxJumpSpeed() {
  const startY = GROUND_Y - DINO_HEIGHT;                // starting y at ground
  const rise    = Math.max(1, startY - TOP_MARGIN);     // distance to top
  // v0 = sqrt(2 * g * rise)
  return Math.sqrt(2 * GRAVITY_ASC * rise);
}
const MAX_JUMP_SPEED = computeMaxJumpSpeed();

const DINO_X = 50;

let dino = {}, cacti = [], cactusTimer = 0;
let score = 0, highScore = 0, gameOver = false;
let restartTimer = 0;

function initDino() {
  dino = { x: DINO_X, y: GROUND_Y - DINO_HEIGHT, vy: 0, jumping: false, alive: true, frame: 0, legSwap: false };
}

function drawDino() {
  ctx.save();
  ctx.translate(dino.x, dino.y);
  ctx.fillStyle = "#666";
  ctx.fillRect(0, 10, 34, 30);
  ctx.fillRect(28, 0, 16, 18);
  ctx.fillStyle = "#fff"; ctx.fillRect(39, 6, 3, 3);
  ctx.fillStyle = "#222"; ctx.fillRect(40, 7, 1, 1);
  ctx.fillStyle = "#444"; ctx.fillRect(10, 30, 8, 6); ctx.fillRect(24, 30, 8, 6);
  ctx.fillStyle = "#333";
  if (dino.legSwap) { ctx.fillRect(8, 40, 8, 7); ctx.fillRect(24, 40, 8, 7); }
  else              { ctx.fillRect(14, 40, 8, 7); ctx.fillRect(18, 40, 8, 7); }
  ctx.restore();
}

function drawCactus(c) {
  ctx.save();
  ctx.translate(c.x, c.y);
  ctx.fillStyle = "#228B22";
  ctx.fillRect(0, 0, CACTUS_WIDTH, CACTUS_HEIGHT);
  ctx.fillRect(-5, 10, 5, 15);
  ctx.fillRect(CACTUS_WIDTH, 20, 5, 10);
  ctx.restore();
}

function drawGround() {
  ctx.strokeStyle = "#888"; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(0, GROUND_Y + 1); ctx.lineTo(LOGICAL_W, GROUND_Y + 1); ctx.stroke();
}

function drawScore() {
  ctx.font = "20px monospace";
  ctx.fillStyle = "#444";
  ctx.fillText("Score: " + score, 10, 30);
  ctx.fillText("High: " + highScore, 10, 55);
}

function update() {
  if (!gameOver) {
    dino.frame++; if (dino.frame % 14 === 0) dino.legSwap = !dino.legSwap;

    if (dino.jumping) {
      // Ascent vs descent gravity
      if (dino.vy < 0) dino.vy += GRAVITY_ASC;
      else             dino.vy += GRAVITY_DESC;
      dino.y += dino.vy;

      // ===== Ceiling clamp: never go beyond the top border =====
      if (dino.y < TOP_MARGIN) {
        dino.y = TOP_MARGIN;
        dino.vy = 0; // start descending next frame (GRAVITY_DESC)
dino.jumping = false;
      }

      // Land on ground
      if (dino.y >= GROUND_Y - DINO_HEIGHT) {
        dino.y = GROUND_Y - DINO_HEIGHT;
        dino.vy = 0; dino.jumping = false;
      }
    }

    // Enemies: spawn/move/cull
    cactusTimer--;
    if (cactusTimer <= 0) {
      cacti.push({ x: LOGICAL_W, y: GROUND_Y - CACTUS_HEIGHT, width: CACTUS_WIDTH, height: CACTUS_HEIGHT });
      cactusTimer = 120 + Math.floor(Math.random() * 60);
    }
    for (let i = 0; i < cacti.length; i++) cacti[i].x -= ENEMY_SPEED;
    cacti = cacti.filter(c => c.x + c.width > 0);

    // Collisions
    for (let c of cacti) {
      if (DINO_X + DINO_WIDTH > c.x && DINO_X < c.x + c.width && dino.y + DINO_HEIGHT > c.y && dino.y < c.y + c.height) {
        gameOver = true; dino.alive = false;
        if (score > highScore) highScore = score;
        restartTimer = 60;
      }
    }
    score++;
  } else {
    restartTimer--; if (restartTimer <= 0) restart();
  }
}

function draw() {
  ctx.save();
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Uniform scale + center (no distortion; letterbox/pillarbox as needed)
  ctx.translate(offX, offY);
  ctx.scale(uniScale, uniScale);

  drawGround();
  drawDino();
  for (let c of cacti) drawCactus(c);
  drawScore();

  if (gameOver) {
    ctx.font = "32px monospace";
    ctx.fillStyle = "#c00";
    ctx.fillText("GAME OVER", LOGICAL_W/2 - 100, 100);
  }
  ctx.restore();
}

let paused = false;
function loop() {
  if (!paused) { update(); draw(); }
  requestAnimationFrame(loop);
}

/* ===== Jump APIs ===== */

// Any jump goes to border (top). Optional BOOST keeps feel “double higher”,
// but we still clamp at the top so you never overshoot the canvas.
function jumpToBorder() {
  if (!gameOver && !dino.jumping) {
    let speed = MAX_JUMP_SPEED;
    if (DOUBLE_HIGHER_MODE) speed *= 2;  // boosted launch, still clamped to top
    dino.vy = -speed;
    dino.jumping = true;
  }
}

// Backward compatible button/tap jump → also to border
function jump() { jumpToBorder(); }

function restart() {
  initDino(); cacti = []; cactusTimer = 0; score = 0; gameOver = false;
}

/* ---------------- App bootstrap ---------------- */
function startApp() {
  initWebcamAndDetector();
  restart();
  loop();

  // Fallback controls
  overlay.addEventListener('click', jump);
  window.addEventListener('keydown', (e) => { if (e.code === 'Space' || e.code === 'ArrowUp') jump(); });

  // Pause when tab hidden
  document.addEventListener('visibilitychange', () => { paused = document.hidden; });

  // Cleanup
  window.addEventListener('beforeunload', async () => {
    try { if (detector) await detector.dispose(); } catch {}
    const tracks = video.srcObject?.getTracks?.() || [];
    tracks.forEach(t => t.stop());
  });
}
</script>

</body>
</html>
