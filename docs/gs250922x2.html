<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dino Jump — Eye-Up Gesture (MoveNet, CDN Fallback & Diagnostics)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#f7f7f7; color:#222; }
    #game { display:block; margin:20px auto; border:2px solid #888; background:#fff; }
    #info  { text-align:center; margin-top:6px; }
    #status { display:inline-block; margin-bottom:6px; }
    #errorMsg { color:#c00; white-space:pre-wrap; max-width:800px; margin:6px auto; }
    #webcam { position:fixed; top:10px; right:10px; width:160px; border:2px solid #444; border-radius:4px; }
    #overlay { position:fixed; top:10px; right:10px; width:160px; pointer-events:auto; }
    #overlayTapHint { position:fixed; top:10px; right:10px; width:160px; text-align:center; color:#222; font-size:12px; pointer-events:none; }
    /* Diagnostics banner */
    #diag { position:fixed; left:10px; top:10px; background:#fff; border:1px solid #ccc; padding:6px 8px; font:12px monospace; border-radius:4px; z-index:9999; }
    #diag b { color:#0a0; }
    #diag i { color:#a00; }
  </style>
</head>
<body>

<div id="diag">Loading…</div>

<canvas id="game" width="600" height="200"></canvas>

<div id="info">
  <span id="status">Allow camera, then move your <strong>eyes up</strong> to jump.</span>
  <div id="errorMsg"></div>
</div>

<!-- Webcam preview + overlay -->
<video id="webcam" autoplay playsinline muted></video>
<canvas id="overlay"></canvas>
<div id="overlayTapHint">Tip: tap the preview or press Space/↑ to jump</div>

<!-- ====== Load TFJS & Pose Detection with automatic fallback ====== -->
<script>
  (function loadLibs(){
    const head = document.head;

    function add(src) {
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = src;
        s.onload = () => resolve(src);
        s.onerror = () => reject(new Error('Failed: ' + src));
        head.appendChild(s);
      });
    }

    async function boot() {
      const diag = (msg) => document.getElementById('diag').innerHTML = msg;

      // Try jsDelivr first, then fall back to unpkg if blocked.
      try {
        await add("https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js");
      } catch {
        await add("https://unpkg.com/@tensorflow/tfjs@4.18.0/dist/tf.min.js");
      }

      try {
        await add("https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.js");
      } catch {
        await add("https://unpkg.com/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.js");
      }

      // Quick diagnostics for library load
      const tfOK  = !!(window.tf);
      const pdOK  = !!(window.poseDetection);
      diag(`TFJS: ${tfOK ? '<b>ok</b>' : '<i>missing</i>'} • Pose-Detection: ${pdOK ? '<b>ok</b>' : '<i>missing</i>'}`);

      if (tfOK && pdOK) {
        setTimeout(startApp, 10);
      } else {
        console.error('Libraries not loaded:', { tfOK, pdOK });
      }
    }
    boot();
  })();
</script>

<!-- ====== App code ====== -->
<script>
/* ================================================================
   Dino Jump with MoveNet — Eye-Up Trigger
   - Eye keypoint(s): average of left/right when both confident,
     or fallback to whichever is confident.
   - Upward-only detection with smoothing & cooldown.
   - No ESM imports; uses global `tf` and `poseDetection`.
   ================================================================ */

const video = document.getElementById('webcam');
const overlay = document.getElementById('overlay');
const octx = overlay.getContext('2d');
const statusText = document.getElementById('status');
const errorMsg = document.getElementById('errorMsg');

let detector;

// --- Eye-based gesture tracking constants/vars ---
const eyeHistory = [];
const HISTORY_LENGTH = 8;
// Eyes move slightly less than nose; start at ~6% of video height
const GESTURE_THRESHOLD_RATIO = 0.06;

let jumpCooldown = 0;
// Light smoothing to reduce jitter
let smoothY = null;
const SMOOTH_ALPHA = 0.25;

function setDiag(extra) {
  const tfOK  = !!(window.tf);
  const pdOK  = !!(window.poseDetection);
  document.getElementById('diag').innerHTML =
    `TFJS: ${tfOK ? '<b>ok</b>' : '<i>missing</i>'} • Pose-Detection: ${pdOK ? '<b>ok</b>' : '<i>missing</i>'}` +
    (extra ? ' • ' + extra : '');
}

// ---------- Hi‑DPI canvas scaling ----------
function fitCanvasToDPR(canvasEl) {
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rect = canvasEl.getBoundingClientRect();
  canvasEl.width  = Math.round(rect.width  * dpr);
  canvasEl.height = Math.round(rect.height * dpr);
  const ctx = canvasEl.getContext('2d');
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
function resizeOverlay() {
  overlay.style.width  = video.offsetWidth + "px";
  overlay.style.height = video.offsetHeight + "px";
  fitCanvasToDPR(overlay);
}

// ---------- Webcam + Detector ----------
async function initWebcamAndDetector() {
  try {
    // Prefer WebGL backend for speed, but fall back if needed
    try { await tf.setBackend('webgl'); } catch { await tf.setBackend('cpu'); }
    await tf.ready();

    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "user" },
      audio: false
    });
    video.srcObject = stream;

    await video.play(); // iOS needs autoplay+muted+playsinline
    statusText.textContent = "Camera ready. Move your eyes UP to jump!";
    video.onloadedmetadata = () => resizeOverlay();

    setDiag('camera: <b>ok</b>');

    // Create MoveNet Lightning (fast single‑pose)
    detector = await poseDetection.createDetector(
      poseDetection.SupportedModels.MoveNet,
      {
        modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
        enableSmoothing: true
      }
    );

    detectPose();
  } catch (e) {
    errorMsg.textContent = "Error initializing webcam or detector:\n" + (e.stack || e.message || e);
    setDiag('<i>camera/detector error</i>');
  }
}

function drawEyeDot(x, y) {
  octx.save();
  octx.fillStyle = "rgba(30,144,255,0.95)"; // DodgerBlue for eyes
  octx.beginPath();
  octx.arc(x, y, 4, 0, Math.PI * 2);
  octx.fill();
  octx.restore();
}

async function detectPose() {
  try {
    if (!detector || video.videoWidth === 0 || video.videoHeight === 0) {
      requestAnimationFrame(detectPose);
      return;
    }
    resizeOverlay();
    octx.clearRect(0, 0, overlay.width, overlay.height);

    const poses = await detector.estimatePoses(video);
    if (poses.length > 0) {
      const kp = poses[0].keypoints;

      // Extract eyes (MoveNet returns 'left_eye' and 'right_eye')
      const leftEye  = kp.find(k => k.name === 'left_eye');
      const rightEye = kp.find(k => k.name === 'right_eye');

      const MIN_EYE_SCORE = 0.5;
      const leftOK  = leftEye  && leftEye.score  > MIN_EYE_SCORE;
      const rightOK = rightEye && rightEye.score > MIN_EYE_SCORE;

      let eye = null;
      if (leftOK && rightOK) {
        eye = {
          x: (leftEye.x + rightEye.x) / 2,
          y: (leftEye.y + rightEye.y) / 2,
          score: Math.min(leftEye.score, rightEye.score)
        };
      } else if (leftOK) {
        eye = leftEye;
      } else if (rightOK) {
        eye = rightEye;
      }

      if (eye) {
        // Smooth y to reduce jitter
        smoothY = (smoothY == null) ? eye.y : (SMOOTH_ALPHA * eye.y + (1 - SMOOTH_ALPHA) * smoothY);

        // Keep short history
        eyeHistory.push(smoothY);
        if (eyeHistory.length > HISTORY_LENGTH) eyeHistory.shift();

        // Visual debug marker
        drawEyeDot(eye.x, eye.y);

        // Upward-only trigger (canvas Y increases downward)
        if (eyeHistory.length === HISTORY_LENGTH && jumpCooldown === 0) {
          const baselineAvg = eyeHistory
            .slice(0, HISTORY_LENGTH - 2)
            .reduce((a, b) => a + b, 0) / (HISTORY_LENGTH - 2);

          const delta = baselineAvg - smoothY; // positive if moved up
          const thresholdPx = (overlay.height || 120) * GESTURE_THRESHOLD_RATIO;

          if (delta > thresholdPx) {
            jump();
            jumpCooldown = 15; // debounce frames
          }
        }
      }
    }
  } catch (err) {
    errorMsg.textContent = "Pose detection error:\n" + (err.stack || err.message || err);
  }

  if (jumpCooldown > 0) jumpCooldown--;
  requestAnimationFrame(detectPose);
}

// ---------- Game ----------
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const GROUND_Y = 170;
const DINO_WIDTH = 44, DINO_HEIGHT = 47;
const CACTUS_WIDTH = 20, CACTUS_HEIGHT = 40;
const GRAVITY = 0.35;
const JUMP_VELOCITY = -6;
const DINO_X = 50;

let dino = {}, cacti = [], cactusTimer = 0;
let score = 0, highScore = 0, gameOver = false;
let restartTimer = 0;

function initDino() {
  dino = { x: DINO_X, y: GROUND_Y - DINO_HEIGHT, vy: 0, jumping: false, alive: true, frame: 0, legSwap: false };
}

function drawDino() {
  ctx.save();
  ctx.translate(dino.x, dino.y);
  ctx.fillStyle = "#666";
  ctx.fillRect(0, 10, 34, 30);
  ctx.fillRect(28, 0, 16, 18);
  ctx.fillStyle = "#fff";
  ctx.fillRect(39, 6, 3, 3);
  ctx.fillStyle = "#222";
  ctx.fillRect(40, 7, 1, 1);
  ctx.fillStyle = "#444";
  ctx.fillRect(10, 30, 8, 6);
  ctx.fillRect(24, 30, 8, 6);
  ctx.fillStyle = "#333";
  if (dino.legSwap) {
    ctx.fillRect(8, 40, 8, 7);
    ctx.fillRect(24, 40, 8, 7);
  } else {
    ctx.fillRect(14, 40, 8, 7);
    ctx.fillRect(18, 40, 8, 7);
  }
  ctx.restore();
}

function drawCactus(c) {
  ctx.save();
  ctx.translate(c.x, c.y);
  ctx.fillStyle = "#228B22";
  ctx.fillRect(0, 0, CACTUS_WIDTH, CACTUS_HEIGHT);
  ctx.fillRect(-5, 10, 5, 15);
  ctx.fillRect(CACTUS_WIDTH, 20, 5, 10);
  ctx.restore();
}

function drawGround() {
  ctx.strokeStyle = "#888";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, GROUND_Y + 1);
  ctx.lineTo(canvas.width, GROUND_Y + 1);
  ctx.stroke();
}

function drawScore() {
  ctx.font = "20px monospace";
  ctx.fillStyle = "#444";
  ctx.fillText("Score: " + score, 10, 30);
  ctx.fillText("High: " + highScore, 10, 55);
}

function update() {
  if (!gameOver) {
    dino.frame++;
    if (dino.frame % 14 === 0) dino.legSwap = !dino.legSwap;

    if (dino.jumping) {
      dino.vy += GRAVITY;
      dino.y += dino.vy;
      if (dino.y >= GROUND_Y - DINO_HEIGHT) {
        dino.y = GROUND_Y - DINO_HEIGHT;
        dino.vy = 0;
        dino.jumping = false;
      }
    }

    cactusTimer--;
    if (cactusTimer <= 0) {
      cacti.push({ x: canvas.width, y: GROUND_Y - CACTUS_HEIGHT, width: CACTUS_WIDTH, height: CACTUS_HEIGHT });
      cactusTimer = 120 + Math.floor(Math.random() * 60);
    }

    for (let i = 0; i < cacti.length; i++) cacti[i].x -= 3;
    cacti = cacti.filter(c => c.x + c.width > 0);

    for (let c of cacti) {
      if (dino.x + DINO_WIDTH > c.x && dino.x < c.x + c.width && dino.y + DINO_HEIGHT > c.y && dino.y < c.y + c.height) {
        gameOver = true;
        dino.alive = false;
        if (score > highScore) highScore = score;
        restartTimer = 60;
      }
    }
    score++;
  } else {
    restartTimer--;
    if (restartTimer <= 0) restart();
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawGround();
  drawDino();
  for (let c of cacti) drawCactus(c);
  drawScore();
  if (gameOver) {
    ctx.font = "32px monospace";
    ctx.fillStyle = "#c00";
    ctx.fillText("GAME OVER", canvas.width/2-100, 100);
  }
}

let paused = false;
function loop() {
  if (!paused) { update(); draw(); }
  requestAnimationFrame(loop);
}

function jump() {
  if (!gameOver && !dino.jumping) {
    dino.vy = JUMP_VELOCITY;
    dino.jumping = true;
  }
}

function restart() {
  initDino();
  cacti = [];
  cactusTimer = 0;
  score = 0;
  gameOver = false;
}

function startApp() {
  initWebcamAndDetector();
  restart();
  loop();

  // Fallback controls
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space' || e.code === 'ArrowUp') jump();
  });
  overlay.addEventListener('click', jump);

  // Pause when tab hidden
  document.addEventListener('visibilitychange', () => {
    paused = document.hidden;
  });

  // Cleanup
  window.addEventListener('beforeunload', async () => {
    try { if (detector) await detector.dispose(); } catch {}
    const tracks = video.srcObject && video.srcObject.getTracks ? video.srcObject.getTracks() : [];
    tracks.forEach(t => t.stop());
  });

  // Handle resizes
  window.addEventListener('resize', () => resizeOverlay());
}

// Expose for the loader above
window.startApp = startApp;
</script>

</body>
</html>
